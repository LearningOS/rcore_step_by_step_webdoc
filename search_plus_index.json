{"./":{"url":"./","title":"0. 从零开始写 OS","keywords":"","body":"从零开始写 OS 前言 本系列文章记录了使用 Rust 编程语言编写一个小型操作系统的详细过程。每篇文章包含所需所有所需代码和相关知识点讲解。 源代码 源文档 web 文档 前置知识 简单的 Rust 语法（这个语言的基础使用方式和 C 类似，文章会介绍其新奇的语法） RISCV 汇编（用的不多） 如何使用 在阅读文章以及复现的过程中了解 OS 。 为了方便起见，建议使用 docker ，可以省去配置环境的功夫。 在工作目录下创建 Makefile ： docker: sudo docker run -it --mount type=bind,source=$(shell pwd)/..,destination=/mnt panqinglin/rust_riscv 进入 docker 后，执行 cd mnt ，即可看见工作目录，然后就可以开始写代码啦！ 每一章或小节对应的源代码可以在 git 的分支中找到 reference https://github.com/rcore-os/rCore https://github.com/oscourse-tsinghua/rcore_plus/tree/lab8-rv32-tinyfs https://github.com/chyyuu/rcore_plus/tree/lab1-rv32-interrupt .. https://github.com/chyyuu/rcore_plus/tree/lab8-rv32-fs const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/独立式可执行程序.html":{"url":"docs/独立式可执行程序.html","title":"1. 独立式可执行程序","keywords":"","body":"独立式可执行程序 本章代码对应分支：freestanding-rust-binary 概要 由于我们的目标是编写一个操作系统，所以首先我们需要创建一个独立于操作系统的可执行程序，又称 独立式可执行程序（freestanding executable） 或 裸机程序（bare-metal executable） 。这意味着所有依赖于操作系统的库我们都不能使用。比如 std 中的大部分内容（io, thread, file system, etc.）都需要操作系统的支持，所以这部分内容我们不能使用。 但是，不依赖于操作系统的 rust 的语言特性 我们还是可以继续使用的，比如：迭代器、模式匹配、字符串格式化、所有权系统等。这使得 rust 依旧可以作为一个功能强大的高级语言，帮助我们编写操作系统。 本章我们将介绍： 安装 rust（nightly 版本） 。 创建可执行的 rust 项目。 将创建的 rust 项目修改为 freestanding rust binary ，这包括 禁用 std 库 并解决由此产生的一系列问题。 安装 nightly rust rust 包含：stable、beta、nightly 三个版本。默认情况下我们安装的是 stable 。由于在编写操作系统时需要使用 rust 的一些不稳定的实验功能，所以请根据 rust 官方教程安装 rust nightly 。 安装成功后使用 rustc --version 或 rustup show 查看当前 rust 的版本。 $ rustc --version rustc 1.38.0-nightly (8a58268b5 2019-07-31) 如果未能成功切换 rust 版本，请查看 how to switch rust toolchain 创建并执行 rust binary 项目 使用 cargo new 创建一个新的 rust binary 项目，如下： > cargo new os --bin --edition 2018 > cd os > cargo run Compiling os v0.1.0 (/media/chyyuu/chydata/thecode/rust-related/new_rcore_step_by_step/os) Finished dev [unoptimized + debuginfo] target(s) in 0.97s Running `target/debug/os` Hello, world! cargo new 的参数 含义 os 项目的名称 --bin 可执行项目，和其相对的是库项目 --lib --edition 2018 使用新版 Rust 2018 而不是老旧的 Rust 2015 第一个应用已经能运行了！但这不是我们需要的 OS，而仅仅是一个离不了 OS 的应用程序而已。我们需要建立直接运行在硬件上的 OS。下面将进行进一步探索。 添加 no_std 属性 因为我们的目标是编写一个操作系统，所以我们不能使用任何依赖于操作系统的库。 项目默认是链接标准库的，我们需要显式地将其禁用： #![no_std] fn main() { println!(\"Hello, world!\"); } 如果此时执行 cargo build 构建项目，会产生以下两个错误： error: cannot find macro `println!` in this scope --> src/main.rs:6:5 | 6 | println!(\"Hello, world!\"); | ^^^^^^^ error: `#[panic_handler]` function required, but not found 现在我们来依次解决这两个问题。 FIX error: cannot find macro 'println!' in this scope println 宏属于标准库，所以禁用标准库后自然不能再使用 println 。由于我们当前目标只是写一个可执行的文件，所以将其删除即可： #![no_std] fn main() {} FIX error: '#[panic_handler]' function required, but not found 在程序发生 panic 时需要调用相应函数。标准库有对应函数，但是由于我们使用了 no_std 属性，所以接下来我们需要自己实现一个函数： use core::panic::PanicInfo; // This function is called on panic. #[panic_handler] fn panic(_info: &PanicInfo) -> ! { loop {} } 由于程序 panic 后就应该结束，所以用 -> ! 表示该函数不会返回。由于目前的 OS 功能还很弱小，所以只能无限循环。 解决了上述两个 error 后，再次执行 cargo build ，结果出现了新的 error： error: language item required, but not found: `eh_personality` FIX error: language item required, but not found: 'eh_personality' eh_personality 语义项（language item）是 exception handling personality 的意思。 我们不使用该项，故直接将 dev (use for cargo build) 和 release (use for cargo build --release) 的 panic 的处理策略设为 abort。 # in Cargo.toml [profile.dev] panic = \"abort\" [profile.release] panic = \"abort\" // in main.rs #[no_mangle] pub extern fn abort() { panic!(\"abort!\"); } 通常，当程序出现了异常 (这里指类似 Java 中层层抛出的异常)，从异常点开始会沿着 caller 调用栈一层一层回溯，直到找到某个函数能够捕获 (catch) 这个异常。这个过程称为 堆栈展开 (stack unwinding) 回溯的时候， caller 中也许会有局部变量需要清理，比如 C++ 的 RAII 的析构或者 Rust 的 drop exception handling personality 是一个函数，它对于每个 caller 函数执行这个过程 这是一个复杂的过程，并且还依赖其他各种库文件 上面设置为 abort ，是指 OS panic 时那么我们不做任何清理的意思，这样相对简单 再次运行 cargo build ，发现出现了新的 error： error: requires `start` lang_item FIX error: requires 'start' lang_item 对于大多数语言，他们都使用了 运行时系统(runtime system) ，这导致 main 并不是他们执行的第一个函数。 以 rust 语言为例：一个典型的 rust 程序会先链接标准库，然后运行 C runtime library 中的 crt0(C runtime zero) 设置 C 程序运行所需要的环境(比如：创建堆栈，设置寄存器参数等)。然后 C runtime 会调用 rust runtime 的 入口点(entry point) 。rust runtime 结束之后才会调用 main 。由于我们的程序无法访问 rust runtime 和 crt0 ，所以需要重写覆盖 crt0 入口点： #![no_std] // don't link the Rust standard library #![no_main] // disable all Rust-level entry points use core::panic::PanicInfo; // This function is called on panic. #[panic_handler] fn panic(_info: &PanicInfo) -> ! { loop {} } #[no_mangle] // don't mangle the name of this function pub extern \"C\" fn _start() -> ! { // this function is the entry point, since the linker looks for a function named `_start` by default loop {} } 适用于 Linux ，在其他系统请 参考 phil-opp 的博客 。暂时无法编译也没关系，因为下一章会重写 _start 函数 #[no_mangle] 属性用于防止改名称被混淆。由于 start 只能由操作系统或引导加载程序直接调用，不会被其他函数调用，所以不能够返回。如果需要离开该函数，应该使用 exit 系统调用。但是由于我们的操作系统还没有实现 exit 系统调用，所以暂时使用无限循环防止函数返回。由于 start 函数无法返回或退出，自然也就不会调用 main 。所以将 main 函数删除，并且增加属性标签 #![no_main] 。 再次执行 cargo build ，很不幸，又出现了 error： linking with `cc` failed: exit code: 1 但幸运的是，这是我们本章所需要处理的最后一个 error! FIX error: linking with 'cc' failed: exit code: 1 在链接 C runtime 时，会需要一些 C 标准库(libc)的内容。由于 #![no_std] 禁用了标准库，所以我们需要禁用常规的 C 启动例程。 于是将之前的 cargo build 换成如下的命令就好啦： > cargo rustc -- -C link-arg=-nostartfiles Compiling os v0.1.0 (/mnt/os) Finished dev [unoptimized + debuginfo] target(s) in 0.21s 适用于 Linux ，在其他系统请 参考 phil-opp 的博客 。暂时无法编译也没关系，后面的章节也用不到。 生成的可执行程序在 target/debug/ 中，在 Cargo.toml 同级目录下执行如下命令可以看到 $ ls target/debug/os -l -rwxr-xr-x 2 dzy dzy 10680 Aug 1 16:55 target/debug/os 历经千辛万苦，我们终于成功构建了一个 Freestanding Rust Binary ！！！ 尽管它现在没有任何功能 预告 下一章，我们将在 Freestanding Rust Binary 的基础上，创建 最小内核 ，将其和 bootloader 链接成为可以被 qemu 加载的 bootimage ，并且将能够在屏幕上打印 Hello World ! const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/最小化内核.html":{"url":"docs/最小化内核.html","title":"2. 最小化内核","keywords":"","body":"最小化内核 本章代码对应分支：min-kernel 概要 本章我们将把上一章创建的 独立可执行程序 编译为内核，并和 bootloader 链接成为可以被 qemu 加载的 bootimage 。为此我们将介绍： 使用 目标三元组 描述目标操作系统。 使用 cargo xbuild 和 目标三元组 编译内核。 将 内核 和 bootloader 链接成 bootimage 。 修改 _start ，使其能够对堆栈进行一些简单的初始化。 建立编译目标三元组和 linker.ld cargo 在编译内核时，可以用过 --target 支持不同的系统。 target triple 包含：cpu 架构、供应商、操作系统和 ABI 。 由于我们在编写自己的操作系统，所以所有目前的 目标三元组 都不适用。幸运的是，rust 允许我们用 JSON 文件定义自己的 目标三元组 。 首先我们来看一下 x86_64-unknown-linux-gnu 的 JSON 文件： { \"llvm-target\": \"x86_64-unknown-linux-gnu\", \"data-layout\": \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\", \"arch\": \"x86_64\", \"target-endian\": \"little\", \"target-pointer-width\": \"64\", \"target-c-int-width\": \"32\", \"os\": \"linux\", \"executables\": true, \"linker-flavor\": \"gcc\", \"pre-link-args\": [\"-m64\"], \"morestack\": false } 因为我们的主要目的是编写 os ，所以这里直接给出目标文件的实现： // in riscv32-os.json { \"llvm-target\": \"riscv32\", \"data-layout\": \"e-m:e-p:32:32-i64:64-n32-S128\", \"target-endian\": \"little\", \"target-pointer-width\": \"32\", \"target-c-int-width\": \"32\", \"os\": \"none\", \"arch\": \"riscv32\", \"cpu\": \"generic-rv32\", \"features\": \"+m,+a,+c\", \"max-atomic-width\": \"32\", \"linker\": \"rust-lld\", \"linker-flavor\": \"ld.lld\", \"pre-link-args\": { \"ld.lld\": [\"-Tsrc/boot/linker.ld\"] }, \"executables\": true, \"panic-strategy\": \"abort\", \"relocation-model\": \"static\", \"eliminate-frame-pointer\": false } 对文件各参数细节感兴趣的读者可以自行研究，这里只对 pre-link-args 进行解释： \"pre-link-args\": { \"ld.lld\": [\"-Tsrc/boot/linker.ld\"] }, 这里我们需要使用指定的链接器，这里同样直接给出 linker.ld 的实现，请自行创建好 src/boot/linker.ld 文件： /* Copy from bbl-ucore : https://ring00.github.io/bbl-ucore */ /* Simple linker script for the ucore kernel. See the GNU ld 'info' manual (\"info ld\") to learn the syntax. */ OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80400000; SECTIONS { /* Load the kernel at this address: \".\" means the current address */ . = BASE_ADDRESS; start = .; .text : { stext = .; *(.text.entry) *(.text .text.*) . = ALIGN(4K); etext = .; } .rodata : { srodata = .; *(.rodata .rodata.*) . = ALIGN(4K); erodata = .; } .data : { sdata = .; *(.data .data.*) edata = .; } .stack : { *(.bss.stack) } .bss : { sbss = .; *(.bss .bss.*) ebss = .; } PROVIDE(end = .); } 运行 cargo build --target riscv32-os.json ，发现编译失败了： error[E0463]: can't find crate for `core` 错误的原因是：no_std 的程序会隐式地链接到 rust 的 core 库 。 core 库 包含基础的 Rust 类型，如 Result、Option 和迭代器等。Rust 工具链中默认只为原生的目标三元组提供了预编译好的 core 库，而我们在编写 os 时使用的是自定义的目标三元组 。 因此我们需要为这些目标重新编译整个 core 库 。这时我们就需要 cargo xbuild 。 使用 Cargo xbuild 重新编译 core 库 这个工具封装了 cargo build 。同时，它将自动交叉编译 core 库 和一些 编译器内建库(compiler built-in libraries) 。我们可以用下面的命令安装它： cargo install cargo-xbuild 现在运行命令来编译目标程序： cargo xbuild --target riscv32-os.json 但我们发现产生了编译错误： error: The sysroot can't be built for the Stable channel. Switch to nightly. note: run with `RUST_BACKTRACE=1` for a backtrace 使用 nightly rust toolchains 这个错误是由于没有使用 nightly 版本的工具链。相比较于 stable rust(default) ，nightly rust 可以使用一些 unsafe 的功能，这在编写 os 时是不可避免的。为此需要在项目目录下建立一个 rust-toolchain 文件，文件内容是工具链的版本信息： nightly-2019-09-02 也可以直接切换 toolchain 这样，在后续编译 rust 程序时，将采用上述版本的 rust 工具链。重新执行 cargo xbuild --target riscv32-os.json ，发现我们的内核已经可以正确编译了。接下来的任务就是将他和 bootloader 链接，得到可以被 qemu 加载的 os 。 检查一下编译出来的内核镜像 $ cargo xbuild --target riscv32-os.json # 编译成功后, 执行如下命令可以查看内核信息 $ file target/riscv32-os/debug/os target/riscv32-os/debug/os: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, with debug_info, not stripped 使用 bootloader 创建引导镜像 编写一个 bootloader 并不是一个简单的事情，所以我们直接使用已有的 bootloader：OpenSBI。 我们从它的 GitHub 上下载最新的 预编译版本（2019 年 7 月的最新版是 v0.4），解压后将其中的 platform/qemu/virt/firmware/fw_jump.elf 复制为 os/opensbi/virt.elf 。 有了 bootloader ，接下来将其与我们的内核链接成 引导映像 就可以了。为了以后能够方便的进行编译链接，我们编写一个 Makefile 文件（与 Cargo.toml 位于同级目录）: target := riscv32-os mode := debug kernel := target/$(target)/$(mode)/os bin := target/$(target)/$(mode)/kernel.bin usr_path := usr export SFSIMG = $(usr_path)/rcore32.img .PHONY: all clean run build asm qemu kernel all: build build: $(bin) run: build qemu kernel: @cargo xbuild --target riscv32-os.json $(bin): kernel @riscv64-unknown-elf-objcopy $(kernel) --strip-all -O binary $@ asm: @riscv64-unknown-elf-objdump -d $(kernel) | less qemu: @qemu-system-riscv32 -nographic -machine virt \\ -kernel opensbi/virt.elf \\ -device loader,file=$(bin),addr=0x80400000 这里我们还需要安装 RISC-V GCC 工具链，可以使用 SiFive 公司提供的 预编译版本。使用方式可参考 how to use \"Prebuilt RISC‑V GCC Toolchain\" 执行 make kernel 生成的 kernel.bin 就是我们需要的 可以被 bootloader 引导的 os 二进制文件 。 执行 make run ，可以看到 bootloader 输出的信息： OpenSBI v0.4 (Jul 2 2019 11:54:59) ____ _____ ____ _____ / __ \\ / ____| _ \\_ _| | | | |_ __ ___ _ __ | (___ | |_) || | | | | | '_ \\ / _ \\ '_ \\ \\___ \\| _ 至此，我们的 最小内核 已经“成功”跑起来了！！！吗？？？ 退出 qemu 的方法是，按下 Ctrl+A 之后再按 X 即可。当然你也可以直接杀掉 qemu 进程 killall qemu-system-riscv32 适配 SBI SBI 是 Supervisor Binary Interface 的简称，OpenSBI 除了作为 bootloader 还实现了 RISCV SBI(即部分 syscall)，比如打印、读取字符等（本质上已经悄悄的实现了一个中断处理机制）。 暂时看不懂就先抄代码，后面会专门讲解 syscall ，可以理解为我们需要 OpenSBI 帮我们进行输出字符的工作。更多内容请参考 官方文档 为了便于使用，我们将 syscall 包一层，将其写为函数形式： #![allow(dead_code)] #[inline(always)] fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize { let ret; unsafe { asm!(\"ecall\" : \"={x10}\" (ret) : \"{x10}\" (arg0), \"{x11}\" (arg1), \"{x12}\" (arg2), \"{x17}\" (which) : \"memory\" : \"volatile\"); } ret } pub fn console_putchar(ch: usize) { sbi_call(SBI_CONSOLE_PUTCHAR, ch, 0, 0); } pub fn console_getchar() -> usize { sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0) } pub fn shutdown() { sbi_call(SBI_SHUTDOWN, 0, 0, 0); } pub fn set_timer(stime_value: u64) { #[cfg(target_pointer_width = \"32\")] sbi_call( SBI_SET_TIMER, stime_value as usize, (stime_value >> 32) as usize, 0, ); #[cfg(target_pointer_width = \"64\")] sbi_call(SBI_SET_TIMER, stime_value as usize, 0, 0); } pub fn clear_ipi() { sbi_call(SBI_CLEAR_IPI, 0, 0, 0); } pub fn send_ipi(hart_mask: usize) { sbi_call(SBI_SEND_IPI, &hart_mask as *const _ as usize, 0, 0); } pub fn remote_fence_i(hart_mask: usize) { sbi_call(SBI_REMOTE_FENCE_I, &hart_mask as *const _ as usize, 0, 0); } pub fn remote_sfence_vma(hart_mask: usize, _start: usize, _size: usize) { sbi_call(SBI_REMOTE_SFENCE_VMA, &hart_mask as *const _ as usize, 0, 0); } pub fn remote_sfence_vma_asid(hart_mask: usize, _start: usize, _size: usize, _asid: usize) { sbi_call( SBI_REMOTE_SFENCE_VMA_ASID, &hart_mask as *const _ as usize, 0, 0, ); } const SBI_SET_TIMER: usize = 0; const SBI_CONSOLE_PUTCHAR: usize = 1; const SBI_CONSOLE_GETCHAR: usize = 2; const SBI_CLEAR_IPI: usize = 3; const SBI_SEND_IPI: usize = 4; const SBI_REMOTE_FENCE_I: usize = 5; const SBI_REMOTE_SFENCE_VMA: usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID: usize = 7; const SBI_SHUTDOWN: usize = 8; 打印字符 直接在 _start 里进行过多的操作并不是一件优雅的事情，而把所有代码都堆在 main 文件里更不好，所以趁着我们的文件还不多，先把他们整理一下吧： main.rs #![no_std] // don't link the Rust standard library #![no_main] // disable all Rust-level entry points #[allow(unused_imports)] use os; boot/extry.asm 我们通过汇编代码来实现 _start 。由于我们使用了 OpenSBI ，所以此时 sp 被设置为指向 M 态内存空间。这里 _start 只做了两件事： 开辟一段新的内存空间作为 rust_main 的运行的堆栈，并使 sp 指向它 跳转到 rust_main .section .text.entry .globl _start _start: lui sp, %hi(bootstacktop) # 将栈指针 sp 置为栈顶地址 call rust_main .section .bss.stack .align 12 # PGSHIFT .global bootstack bootstack: .space 4096 * 4 # 开辟一块栈空间（4个页） .global bootstacktop bootstacktop: init.rs use crate::sbi; global_asm!(include_str!(\"boot/entry.asm\")); // 引入 _start static HELLO: &[u8] = b\"Hello World!\"; #[no_mangle] pub fn rust_main() -> ! { for &c in HELLO { sbi::console_putchar(c as usize); } loop {} } lang_items.rs use core::panic::PanicInfo; #[panic_handler] fn panic(_info: &PanicInfo) -> ! { loop {} } #[no_mangle] pub extern \"C\" fn abort() { panic!(\"abort!\"); } lib.rs #![no_std] #![feature(asm)] #![feature(global_asm)] mod init; mod lang_items; mod sbi; 那么，接下来，就是见证奇迹的时刻： > make run ... Hello World! 以后若无特殊说明，编译运行的命令就是 make run 预告 最黑暗的日子已经过去，我们已经完成了一个可以正常运行的 最小内核 ！下一章我们将在此基础上，实现 rust 中最常用的宏： println! ，用于后续的调试和输出。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/格式化输出.html":{"url":"docs/格式化输出.html","title":"3. 格式化输出","keywords":"","body":"格式化输出 本章代码对应分支：fmt-print 概要 通过上一章，我们已经可以在屏幕上打印简单的字符串了，但是我们不应该满足于此。本章我们将实现 rust 中最经典的宏： println! ，用于后续的调试和输出。这需要我们对 rust 的一些特性有一定的了解： 宏的使用。 trait 的特性。 简单打印字符和字符串 在一个文件内实现过多的功能会使得文件过于冗长，不易阅读与维护，所以我们（在 main.rs 的同级目录下）创建一个新的文件用于管理 io 。现在我们来为 io 实现两个最简单的函数： io.rs use crate::sbi; pub fn putchar(ch: char) { sbi::console_putchar(ch as u8 as usize); } pub fn puts(s: &str) { for ch in s.chars() { putchar(ch); } } lib.rs pub mod io; 修改 rust_main 为： #[no_mangle] pub fn rust_main() -> ! { crate::io::puts(\"666666\"); loop {} } 编译运行，屏幕成功输出了 666666 ！ 实现 println! io.rs #[macro_export] macro_rules! print { ($($arg:tt)*) => ({ $crate::io::_print(format_args!($($arg)*)); }); } #[macro_export] macro_rules! println { () => ($crate::print!(\"\\n\")); ($($arg:tt)*) => ($crate::print!(\"{}\\n\", format_args!($($arg)*))); } #[macro_export] 宏使得外部的库也可以使用这个宏。 format_args! 宏可以将 print(...) 内的部分转换为 fmt::Arguments 类型，用以后续打印。这里我们用到了一个还未实现的函数： _print 。他的实现方法十分神奇，借助了 rust 奇妙的语法。 rust trait 有点类似 C++ 的抽象类，实现 trait 有点类似继承抽象类。这里我们创建了一个空的结构体，但是，由于它实现了 fmt::Write::write_str ，trait 会帮我们自动实现 fmt::Write::write_fmt 。 如果你想进一步了解这部分内容，可以参考 rust 官方文档 - core::fmt::Write 和 rust 官方教程 - Traits 部分 io.rs use core::fmt::{self, Write}; struct StdOut; impl fmt::Write for StdOut { fn write_str(&mut self, s: &str) -> fmt::Result { puts(s); Ok(()) } } pub fn _print(args: fmt::Arguments) { StdOut.write_fmt(args).unwrap(); } 为了在外部中使用 io.rs 中的宏，我们需要在 pub mod io 的上方添加属性： #[macro_use] mod io; 现在我们可以让 println! 进行一些“高难度”的工作，比如打印 panic 信息： lang_items.rs #[panic_handler] fn panic(info: &PanicInfo) -> ! { println!(\"{}\", info); loop {} } init.rs #[no_mangle] pub fn rust_main() -> ! { let a = \"Hello\"; let b = \"World\"; println!(\"{}, {}!\", a, b); panic!(\"End of rust_main\"); } 再次编译运行，程序输出： Hello, World! panicked at 'End of rust_main', src/main.rs:25:5 预告 当 CPU 访问无效的寄存器地址，或进行除零操作，或者进行 系统调用 时，会产生中断。下一章，我们将实现一个简单的中断机制对这些情况进行处理。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/中断异常.html":{"url":"docs/中断异常.html","title":"4. 中断异常","keywords":"","body":"中断异常 概要 CPU 运行到一些情况下会产生 异常(exception) ，例如访问无效的内存地址、执行非法指令（除零）、发生缺页等。用户程序进行 系统调用(syscall) ，或程序运行到 断点(breakpoint) 时，也会主动触发异常。 和异常类似的一个概念是中断(interrupt)。中断指的是 CPU 运行过程被外部信号打断，这些信号一般由 CPU 之外的硬件产生，表示某些事件发生，例如定时器倒计时结束、串口收到数据等。 当发生中断或异常时，CPU 会立即跳转到一个预先设置好的地址，执行中断处理程序，最后恢复原程序的执行。 本章中我们会实现一个简单的中断处理程序，具体分为以下部分： 设置中断入口点 创建 中断帧（TrapFrame） 结构体 在中断处理程序中保存和恢复寄存器 进行具体的中断处理 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/Trap.html":{"url":"docs/Trap.html","title":"4.1 Trap","keywords":"","body":"Trap 本章代码对应分支：trap RISCV 中的中断异常 在 RISCV 特权指令集手册中，描述了与中断处理相关的 CSR 寄存器： sscratch: 一个字的临时存储空间，一般用来辅助中断处理 sstatus: 系统状态寄存器 stvec: 中断跳转地址 scause: 中断或异常的原因 sepc: 发生中断时的位置 / PC 与中断相关的指令： sret: S 态中断返回 ecall: 向底层执行环境发出调用请求，用来进行系统调用 ebreak: 触发断点异常 为了能够方便的对寄存器进行操作，我们引入头文件 riscv ： Cargo.toml [dependencies] riscv = { path = \"crate/riscv\", features = [\"inline-asm\"] } # riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } 该头文件基本实现了 riscv 寄存器的所有功能，使得我们可以尽量避免显式使用汇编代码 你可以直接将我的仓库里的代码复制到你的目录下 也可以去 riscv 仓库 自行下载（可能略有不一样） 后续我们会通过相同的方式引入其它头文件 设置中断入口点 当我们的程序遇上中断或异常时，cpu 会跳转到一个指定的地址进行中断处理。在 RISCV 中，这个地址由 stvec 控制寄存器保存： ebreak 和 ecall 严格来说属于主动触发的异常。异常是在执行指令的过程中“同步”发生的，相对地中断则是“异步”发生的，由外部信号触发（如时钟、外设、IPI）。 stvec 中包含了 向量基址（BASE） 和 向量模式（MODE） ，其中 向量基址（BASE） 必须按照 4 字节对齐。 RISCV 中有两种中断入口模式： 直接模式（Driect） MODE = 0 ，触发任何 中断异常 时都把 PC 设置为 BASE 向量模式（Vectored） MODE = 1 ，对第 i 种 中断 ，跳转到 BASE + i * 4；对所有 异常 ，仍跳转到 BASE 为了实现简单，我们采用第一种模式，先进入统一的处理函数，之后再根据中断/异常种类进行不同处理。 在 main.rs 的同级目录下创建 interrupt.rs ： lib.rs mod interrupt; interrupt.rs use riscv::register::{ scause, sepc, stvec, sscratch }; pub fn init() { unsafe { sscratch::write(0); // 给中断 asm 初始化 stvec::write(trap_handler as usize, stvec::TrapMode::Direct); } println!(\"++++setup interrupt !++++\"); } fn trap_handler() -> ! { let cause = scause::read().cause(); let epc = sepc::read(); println!(\"trap: cause: {:?}, epc: {:#x}\", cause, epc); panic!(\"trap\"); } init.rs #[no_mangle] pub fn rust_main() -> ! { crate::interrupt::init(); unsafe{ asm!(\"ebreak\"::::\"volatile\"); } panic!(\"End of rust_main\"); } 由于现在还无法恢复中断，我们用 panic 结束这个函数，并用 -> ! 标记此函数永不返回。 make run 运行，我们看到程序成功触发了异常并进入了处理函数： ++++setup interrupt !++++ trap: cause: Exception(Breakpoint), epc: 0x80400028 panicked at 'trap', src/interrupt.rs:15:5 创建栈帧结构体 上面这个简单的中断处理函数无法返回，原因是处理函数会覆盖掉原有的寄存器信息。为了能够恢复中断之前的状态，我们需要保存当前 所有寄存器 的状态，然后处理中断，最后恢复寄存器状态，继续执行之前的命令。我们需要按照特定的格式保存寄存器，以便于我们使用 中断帧(TrapFrame) 结构体查看或修改这些寄存器。可以理解为，在一片连续的内存空间中存放了我们寄存器的状态，我们通过这片空间的首地址（指针）来访问他们。 riscv32 中有 32 个通用寄存器和部分特殊寄存器。在 main.rs 的同级目录下创建 context.rs 文件。栈帧结构体的实现如下： lib.rs mod context; context.rs use riscv::register::{ sstatus::Sstatus, scause::Scause, }; #[repr(C)] #[derive(Debug)] pub struct TrapFrame { pub x: [usize; 32], // General registers pub sstatus: Sstatus, // Supervisor Status Register pub sepc: usize, // Supervisor exception program counter pub stval: usize, // Supervisor trap value pub scause: Scause, // Scause register: record the cause of exception/interrupt/trap } 其中 #[repr(C)] 表示对这个结构体按 C 语言标准 进行内存布局，也就是从起始地址开始，按字段的定义顺序依次排列。如果不写的话，Rust 对它的内存布局是不确定的，会导致我们无法使用汇编代码对它进行正确的读写。 #[derive(Debug)] 使得我们可以通过 println!(\"{:#?}\", tf) 将其打印出来。 保存和恢复寄存器 在 main.rs 的同级目录下创建 trap/trap.asm 。 在 trap/trap.asm 中实现 __alltraps 函数，用于保存所有寄存器信息，然后跳转到 interrupt.rs 的中断处理函数 rust_trap 。处理结束后，再通过 trap/trap.asm 中的 __trapret 将寄存器恢复到中断前的状态，继续执行中断前的指令。 首先编写中断处理的整体框架： trap/trap.asm .section .text .globl __alltraps __alltraps: SAVE_ALL mv a0, sp jal rust_trap .globl __trapret __trapret: RESTORE_ALL # return from supervisor call sret .globl 表示该符号是一个全局符号，可以被外部访问。 .section .text 将 __alltraps 和 __trapret 放到程序的同一个代码段中，使得 __alltrap 执行完后会继续执行 __trapret 。 SAVE_ALL 和 RESTORE_ALL 稍后实现 看回 __alltrap ，在 jal rust_trap 被调用之前，我们执行了 mv a0, sp 。其中 a0 是 riscv32 中的参数寄存器，用于存放下一个调用的函数的参数。我们将 a0 赋值为 sp ，也就是栈帧的地址。这样便成功的将栈帧作为参数传递给了 rust_trap 。 trap/trap.asm 中，SAVE_ALL 用于保存所有的寄存器的状态，RESTORE_ALL 则用于恢复所有的寄存器的状态。 为了增加代码的可读性，我们还定义了一些宏： .equ XLENB, 4 # 字长为 4 Byte .macro LOAD a1, a2 # 读取内存地址 sp+a2*4 的值到寄存器 a1 lw \\a1, \\a2*XLENB(sp) .endm .macro STORE a1, a2 # 将寄存器 a1 的值保存到内存地址 sp+a2*4 sw \\a1, \\a2*XLENB(sp) .endm SAVE_ALL .macro SAVE_ALL # If coming from userspace, preserve the user stack pointer and load # the kernel stack pointer. If we came from the kernel, sscratch # will contain 0, and we should continue on the current stack. csrrw sp, sscratch, sp bnez sp, trap_from_user trap_from_kernel: csrr sp, sscratch # sscratch = previous-sp, sp = kernel-sp trap_from_user: # provide room for trap frame addi sp, sp, -36*XLENB # save x registers except x2 (sp) STORE x1, 1 STORE x3, 3 STORE x4, 4 STORE x5, 5 STORE x6, 6 STORE x7, 7 STORE x8, 8 STORE x9, 9 STORE x10, 10 STORE x11, 11 STORE x12, 12 STORE x13, 13 STORE x14, 14 STORE x15, 15 STORE x16, 16 STORE x17, 17 STORE x18, 18 STORE x19, 19 STORE x20, 20 STORE x21, 21 STORE x22, 22 STORE x23, 23 STORE x24, 24 STORE x25, 25 STORE x26, 26 STORE x27, 27 STORE x28, 28 STORE x29, 29 STORE x30, 30 STORE x31, 31 # get sp, sstatus, sepc, stval, scause # set sscratch = 0 csrrw s0, sscratch, x0 csrr s1, sstatus csrr s2, sepc csrr s3, stval csrr s4, scause # store sp, sstatus, sepc, sbadvaddr, scause STORE s0, 2 STORE s1, 32 STORE s2, 33 STORE s3, 34 STORE s4, 35 .endm 一上来我们就遇到一个尴尬的局面：中断可能来自用户态（U-Mode），也可能来自内核态（S-Mode）。如果是用户态中断，那么此时的栈指针 sp 指向的是用户栈；如果是内核态中断，那么 sp 指向的是内核栈。现在我们希望把寄存器保存在内核栈上， 这就要求有一个通用寄存器指向内核栈。对于内核态中断来说，直接使用 sp 就可以了，但对于用户态中断，我们需要在不破坏 32 个通用寄存器的情况下，切换 sp 到内核栈。 解决问题的关键是要有一个可做交换操作的临时寄存器，这里就是 sscratch 。 我们规定：当 CPU 处于 U-Mode 时，sscratch 保存内核栈地址；处于 S-Mode 时，sscratch 为 0 。 接下来我们考察中断处理的前三条指令，它们利用 sscratch 的性质巧妙地完成了切换栈的操作： # 交换 sp 和 sscratch 寄存器 csrrw sp, sscratch, sp # 判断 sp（也就是交换前的 sscratch）是否为0 # 如果非0，说明是用户态中断，由于 sscratch 保存的是内核栈地址 # 此时 sp 已经指向内核栈，直接跳转到 trap_from_user 保存寄存器 bnez sp, trap_from_user # 否则说明是内核态中断 trap_from_kernel: # 只需从 sscratch 中读出原来的 sp 即可 csrr sp, sscratch # 此时 sscratch = 发生中断前的 sp # sp = 内核栈 trap_from_user: 后面的事情就比较简单了：此时 sp 指向的是内核栈的栈底，接下来我们要把 TrapFrame 保存在栈上，因此先将它下移相当于 TrapFrame 大小的距离（36 * 4 Byte），然后依次保存除 x0(zero) 和 x2(sp) 外的 30 个通用寄存器： trap_from_user: # 为 TrapFrame 预留空间 addi sp, sp, -36*XLENB # 保存通用寄存器（sp 除外） STORE x1, 1 STORE x3, 3 STORE x4, 4 ... STORE x31, 31 x0 永远是 0，不用保存；sp 本应保存的是发生中断前的值，这个值目前被交换到了 sscratch 中，因此留到后面处理。 接下来保存 CSR 寄存器，此时通用寄存器已经可以随意使用了： # 读取 sp, sstatus, sepc, stval, scause # 按照规定，进入内核态后 sscratch 应为 0 csrrw s0, sscratch, x0 csrr s1, sstatus csrr s2, sepc csrr s3, stval csrr s4, scause # 保存 sp, sstatus, sepc, stval, scause STORE s0, 2 STORE s1, 32 STORE s2, 33 STORE s3, 34 STORE s4, 35 SAVE_ALL 就这样结束了，紧接着两条指令让我们跳转到 Rust 代码： mv a0, sp jal rust_trap interrupt.rs use riscv::register::{ stvec, sscratch }; use crate::context::TrapFrame; global_asm!(include_str!(\"trap/trap.asm\")); pub fn init() { extern { fn __alltraps(); } unsafe { sscratch::write(0); // 给中断 asm 初始化 stvec::write(__alltraps as usize, stvec::TrapMode::Direct); } println!(\"++++setup interrupt !++++\"); } #[no_mangle] pub fn rust_trap(tf: &mut TrapFrame) { println!(\"trap: {:#x?}\", tf); panic!(\"trap\"); } 编译运行，得到以下输出： ++++setup interrupt !++++ trap: TrapFrame { x: [ 0x80407058, 0x80400024, 0x8040cff0, 0x0, 0x8001af00, 0x8001ae50, 0x0, 0x0, 0x8040d000, 0x8001af00, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x82, 0x1, 0x80008500, 0x0, 0x0, 0x0, 0x0, 0x8, 0x2000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, ], sstatus: Sstatus { bits: 0x80006100, }, sepc: 0x80400028, stval: 0x0, scause: Scause { bits: 0x3, }, } panicked at 'trap', src/interrupt.rs:20:5 我们成功保存了发生中断时寄存器的值！ RESTORE_ALL 恢复寄存器 RESTORE_ALL 的过程正好相反。首先根据 sstatus 寄存器中的 SPP 位，判断是回到用户态还是内核态。如果是回到用户态，根据规定需要设置 sscratch 为内核栈： .macro RESTORE_ALL LOAD s1, 32 # s1 = sstatus LOAD s2, 33 # s2 = sepc andi s0, s1, 1 最后 __trapret 通过 sret 指令完成中断返回：CPU 根据 sstatus.SPP 确定特权级，将 sepc 恢复到 PC 。 对 rust_trap 进行一些修改： interrupt.rs #[no_mangle] pub fn rust_trap(tf: &mut TrapFrame) { println!(\"trap!\"); } 再运行一下，发现程序不断地输出 trap! ，说明中断恢复没有问题。 为什么会反复输出 trap! 中断处理 至此我们已经为真正的中断处理函数 rust_trap 建立好了执行环境，免除了恢复中断现场的后顾之忧。后面我们会陆续添加对不同中断和异常种类的处理逻辑。 眼下我们要处理的是断点异常 Breakpoint 。 在 riscv 中，发生中断指令的 pc 被存入 sepc 。对于大部分情况，中断处理完成后还回到这个指令继续执行。但对于用户主动触发的异常（例如ebreak用于触发断点，ecall用于系统调用），中断处理函数需要调整 sepc 以跳过这条指令。 因为我们没有手动调整 sepc ，所以会反复输出 trap! 。 在 riscv 中， 一般 每条指令都是定长的 4 字节（但如果开启 压缩指令集 可就不一定了，这也导致了一个大坑），因此只需将 sepc + 4 即可，这里我们通过 increase_sepc 完成这个功能： context.rs impl TrapFrame { pub fn increase_sepc(self: &mut Self) { self.sepc = self.sepc + 4; } } interrupt.rs #[no_mangle] pub fn rust_trap(tf: &mut TrapFrame) { println!(\"trap!\"); tf.increase_sepc(); } 注意！！！ 这里我们强调了 一般 。在开启 压缩指令集 的情况下，对于常用指令，编译器会进行压缩，减小程序的大小。但是有时候这并不是我们希望的。比如这里因为我们要求每条指令都是精准的 32bits ，才能够通过 self.sepc = self.sepc + 4 跳转至下一条指令（否则会跳转到奇怪的地方）。在 riscv32-os.json 中，有一行 \"features\": \"+m,+a,+c\" 。默认情况下，riscv 指令集只支持加减法， +m 增加了乘除指令； +a 增加了原子操作； +c 增加了代码压缩。这里的压缩是我们不想要的，所以把 +c 删去。 至此我们简易的的中断功能已经全部实现完成，编译运行，屏幕显示： ++++setup interrupt !++++ trap! panicked at 'End of rust_main', src/init.rs:9:5 如果未能正常 panic 可能需要先执行 cargo clean 可以看到，我们已经成功进入中断处理函数，并且返回到了 rust_main ，触发了 panic 。 预告 现在，我们已经实现了简易的中断机制。下一章，我们将在 rust_trap 中区分中断类型，对他们进行不同的处理，并且实现时钟中断。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/时钟中断.html":{"url":"docs/时钟中断.html","title":"4.2. 时钟中断","keywords":"","body":"时钟中断 本章代码对应分支：clock 概要 实现时钟中断。 在 rust_trap 中区分中断类型，根据中断类型进行不同的处理。 初始化时钟 首先，创建 clock.rs ，并在 lib.rs 中加入 mod clock 。 时钟中断，最重要的就是时钟。首先加入计时器，然后对时钟进行初始化： clock.rs use crate::sbi::set_timer; use riscv::register::sie; use riscv::register::{ time, timeh }; pub static mut TICK: usize = 0; static TIMEBASE: u64 = 100000; pub fn init() { unsafe { TICK = 0; sie::set_stimer(); } clock_set_next_event(); println!(\"++++setup timer !++++\"); } pub fn clock_set_next_event() { set_timer(get_cycle() + TIMEBASE); } fn get_cycle() -> u64 { loop { let hi = timeh::read(); let lo = time::read(); let tmp = timeh::read(); if hi == tmp { return ((hi as u64) sie::set_stimer 通过将 mie 寄存器的 STIE 位（第 5 位）设为 1 开启了内核态的时钟中断。 clock_set_next_event 的作用是设置下一次时钟中断触发的时间。riscv 不支持直接设置时钟中断的间隔，只能在每次触发时钟中断的时候，设置下一次时钟中断的时间。TIMEBASE 便是时间间隔，其数值一般约为 cpu 频率的 1% ，防止时钟中断占用过多的 cpu 资源。get_cycle 用于获取当前时间，当前时间加上 TIMEBASE 为下一次中断产生的时间，通过 set_timer 设置。 cpu 中有一个专门用于储存时间的 64 位寄存器。由于 system call 的返回值存放于 32 位的 x10 通用寄存器，所以需要分别读取时间的前 32 位和后 32 位： hi 是时间的高 32 位，lo 是时间的低 32 位。注意到这里并没有之间拼接 hi 和 lo 然后将其返回，而是多了一步 if hi == tmp 判断。这是由于在执行完 let lo = time::read() 后，当前时间会改变。尽管时间的前 32 位改变的概率很小，但是仍然需要进行一次判断。 开启内核态中断 sie 寄存器控制了所有内核态的中断。需要将其 SSIE 位（第 2 位）设为 1 ，内核态才能接受软件中断。 为了能够正确响应内核态的时钟中断，需要将 sie 寄存器进行设置： interrupt.rs use riscv::register::{ stvec, sscratch, sstatus }; #[no_mangle] pub fn init() { extern { fn __alltraps(); } unsafe { sscratch::write(0); // 给中断 asm 初始化 sstatus::set_sie(); stvec::write(__alltraps as usize, stvec::TrapMode::Direct); } println!(\"++++setup interrupt !++++\"); } 现在我们有了两个产生中断的方式： 通过内联汇编使用 ebreak, ecall 。 时钟中断。 响应时钟中断 但是我们的 rust_trap 目前除了会打印 trap! 之外什么都不会。让我们来教他怎么区分中断类型吧： interrupt.rs use riscv::register::scause::{ Trap, Exception, Interrupt }; use crate::clock::{ TICK, clock_set_next_event }; #[no_mangle] pub fn rust_trap(tf: &mut TrapFrame) { match tf.scause.cause() { Trap::Exception(Exception::Breakpoint) => breakpoint(), Trap::Interrupt(Interrupt::SupervisorTimer) => super_timer(), _ => panic!(\"unexpected trap\"), } } fn breakpoint() { panic!(\"a breakpoint set by kernel\"); } fn super_timer() { // 响应当前时钟中断的同时，手动设置下一个时钟中断 clock_set_next_event(); unsafe{ TICK = TICK + 1; if TICK % 100 == 0 { println!(\"100 ticks!\"); } } } tf.scause.cause 表示触发中断的中断类型，这里我们只对两种中断类型进行处理，除此之外的中断则直接 panic。在触发时钟中断时，我们要做的第一件事就是通过 clock_set_next_event 设置下一次中断时间。其余的事情十分简单，只需要把从 clock.rs 中引入的 TICK 加一，表示经过了一个时钟周期。每经过 100 个时钟周期，就在屏幕上打印一些字符。 最后，在 rust_main 中对时钟进行初始化。为了能够看到后面持续产生的时钟中断，需要删掉其原先的 panic ： init.rs #[no_mangle] pub fn rust_main() -> ! { crate::interrupt::init(); crate::clock::init(); loop {} } 这样，我们就成功的设置好了时钟中断。编译运行： ++++setup interrupt !++++ ++++setup timer !++++ 100 ticks! 100 ticks! ... 在 loop {} 之前加上： unsafe { asm!(\"ebreak\"::::\"volatile\"); } ，编译运行： ++++setup interrupt !++++ ++++setup timer !++++ panicked at 'a breakpoint set by kernel', src/interrupt.rs:31:5 预告 本章我们实现了时钟中断，并且能够进行一些简单的中断处理。下一章我们将实现物理内存的分配和释放。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/内存分配.html":{"url":"docs/内存分配.html","title":"5. 内存分配","keywords":"","body":"内存分配 本章代码对应分支：alloc-memory 概要 初始化内核堆。 判断内存的那些部分是可以供我们分配的。 引入 buddy allocator 辅助管理物理内存。 实现物理内存的分配与释放。 初始化内核堆 内存可以在 stack 上分配，在我们的 os 中，stack 的大小在 boot/entry.asm 被定为 4 * 4k 。但是如 Vec ，其内存分配是在 heap 上的。堆的大小取决于 全局分配器 。目前 rust 语言并没有指定 全局分配器 ，有些编译器可能会帮忙指定。#[global_allocator] 标签允许我们实现自己的 全局分配器 。这里如果不指定 全局分配器 会导致后续无法使用 Vec 等数据结构。 more about global allocator 这里我们使用一个现成的适用于本 os 的 全局分配器 ： Cargo.toml [dependencies] buddy_system_allocator = \"0.1\" lib.rs #![feature(alloc_error_handler)] mod memory; mod consts; use buddy_system_allocator::LockedHeap; #[global_allocator] static HEAP_ALLOCATOR: LockedHeap = LockedHeap::empty(); #[alloc_error_handler] fn foo(_: core::alloc::Layout) -> ! { panic!(\"DO NOTHING alloc_error_handler set by kernel\"); } 接下来创建目录和文件，对堆进行初始化： consts.rs pub const KERNEL_HEAP_SIZE: usize = 0x00a0_0000; 大小可以自行规定，合适就行，后续（下一章）将根据实际情况修改它 memory/mod.rs use crate::consts::*; use crate::HEAP_ALLOCATOR; pub fn init(dtb: usize) { use riscv::register::sstatus; unsafe { // Allow user memory access sstatus::set_sum(); } init_heap(); } fn init_heap() { static mut HEAP: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE]; unsafe { HEAP_ALLOCATOR .lock() .init(HEAP.as_ptr() as usize, KERNEL_HEAP_SIZE); } } 这里我们将 sum 位设为 1 。sum（permit supervisor user memory access）位修改 S 模式读、写和指令获取访问虚拟内存的权限。仅当 sum = 1 时则允许在 S 模式下访问属于 U 模式（U = 1）的内存，否则会产生异常 这一步现在还不是必须的，要到用户程序时才能体现出作用 计算可用内存 硬件信息需要通过 device tree 获得，但是略繁琐，所以这里我们暂时直接钦定 MEMORY_END： consts.rs pub const MEMORY_OFFSET: usize = 0x8000_0000; pub const MEMORY_END: usize = 0x8800_0000; pub const PAGE_SIZE: usize = 4096; memory/mod.rs // Symbols provided by linker script extern \"C\" { fn end(); } use frame_allocator::{ init as init_frame_allocator, test as test_frame_allocator }; // TODO pub fn init() { unsafe { sstatus::set_sum(); // Allow user memory access } init_heap(); let memory_start = (end as usize) + PAGE_SIZE; let memory_size = MEMORY_END - memory_start; init_frame_allocator(memory_start, memory_size); test_frame_allocator(); } boot/linker.ld 为 end 赋值，这个是 kernel 的结束虚拟地址，此时由于尚未启用页表，虚实地址相等。在此之后是 device tree base ，我们为其留出 PAGE_SIZE 大小的空间存放 物理内存块的分配与释放 我们将内存整体视为许多连续的“块”，这里我们将每个块的大小定为 4k ，也即 PAGE_SIZE 。那么我们需要一个数据结构来管理这些块：哪些块被分配了、哪些块是空闲的、如何进行分配和释放等。buddy system 就是通过二叉树对内存块进行管理的一种算法。 Cargo.toml 这里提供已经写好的 buddy system 算法 ，请自行下载并放于 crate 目录下： [dependencies] buddy-allocator = { path = \"crate/buddy-allocator\" } lazy_static = { version = \"1.3\", features = [\"spin_no_std\"] } spin = \"0.3\" 算法细节可阅读 伙伴分配器的一个极简实现 也可以直接看提供的代码 memory/frame_allocator/mod.rs 这里我们需要创建一个用于分配内存的 BUDDY_ALLOCATOR 全局静态变量。但是他的值需要在运行时才能被确定。这里 lazy_static 便帮我们解决了这个问题。 同时，为了防止多线程时内存被重复分配，需要使用互斥锁(Mutex)管理 BUDDY_ALLOCATOR 。 什么是 Mutex ？我们用一个现实生活中的例子来理解：假设你去超市买了一个笔记本，付款之后你还没来得及把他拿走，这时来了另一个人，也付了钱，买了这个笔记本。那么这个笔记本属于谁呢？这不是我们乐意见到的。为了防止这种情况，在超市买东西的时候，前一个人的结账尚未完成的时候，下一个人是不能够开始结账的。同样的道理适用于内存块的分配。 use buddy_allocator::{ BuddyAllocator, log2_down }; use lazy_static::*; use spin::Mutex; use riscv::addr::*; use crate::consts::*; // 物理页帧分配器 lazy_static! { pub static ref BUDDY_ALLOCATOR: Mutex = Mutex::new(BuddyAllocator::new()); } pub fn init(start: usize, lenth: usize) { BUDDY_ALLOCATOR.lock() .init(log2_down((start + lenth - MEMORY_OFFSET) / PAGE_SIZE) as u8); alloc_frames((start - MEMORY_OFFSET - 1) / PAGE_SIZE + 1); println!(\"++++init frame allocator succeed!++++\"); } pub fn alloc_frame() -> Option { alloc_frames(1) } pub fn alloc_frames(size: usize) -> Option { let ret = BUDDY_ALLOCATOR .lock() .alloc(size) .map(|id| id * PAGE_SIZE + MEMORY_OFFSET); ret.map(|addr| Frame::of_addr(PhysAddr::new(addr))) } pub fn dealloc_frame(target: Frame) { dealloc_frames(target, 1); } pub fn dealloc_frames(target: Frame, size: usize) { BUDDY_ALLOCATOR .lock() .dealloc(target.start_address().as_usize() / PAGE_SIZE - MEMORY_OFFSET / PAGE_SIZE, size); } riscv::addr::* 引入了 struct Frame 以及一些相关函数。由于 buddy_allocator::alloc 返回的是内存块编号，类型为 Option ，所以需要将其转换为物理地址，然后通过 Frame::of_addr 转换为物理帧。同理，在释放内存时需要进行类似的操作。 这里涉及到一个 rust 的语法：闭包。我们举一个例子便能理解他： Some(233).map(|x| x + 666) = Some(899) 完成了分配和释放内存的函数，让我们来简单的测试一下他的正确性： memory/frame_allocator/mod.rs pub fn test() { let frame1: Frame = alloc_frame().expect(\"failed to alloc frame\"); println!(\"test frame_allocator: {:#x}\", frame1.start_address().as_usize()); let frame2: Frame = alloc_frames(2).expect(\"failed to alloc frame\"); println!(\"test frame_allocator: {:#x}\", frame2.start_address().as_usize()); let frame3: Frame = alloc_frame().expect(\"failed to alloc frame\"); println!(\"test frame_allocator: {:#x}\", frame3.start_address().as_usize()); dealloc_frame(frame1); dealloc_frames(frame2, 2); dealloc_frame(frame3); } init.rs #[no_mangle] pub fn rust_main() -> ! { crate::interrupt::init(); crate::clock::init(); crate::memory::init(); loop {} } 执行 make run ，出现了如下错误： error[E0152]: duplicate lang item found: `oom`. --> src/lib.rs:23:1 | 23 | / fn foo(_: core::alloc::Layout) -> ! { 24 | | panic!(\"DO NOTHING alloc_error_handler set by kernel\"); 25 | | } | |_^ | = note: first defined in crate `buddy_allocator`. error: aborting due to previous error For more information about this error, try `rustc --explain E0152`. error: Could not compile `os`. 这是由于 buddy_allocator 也定义了对内存分配错误的处理函数，这样就和我们之前定义的 alloc_error_handler 冲突了。把我们实现的 alloc_error_handler 删掉即可。再次执行 make run ，编译正确，屏幕输出： ... ++++init frame allocator succeed!++++ test frame_allocator: 0x81000000 test frame_allocator: 0x81002000 test frame_allocator: 0x81001000 100 ticks! ... 仔细观察输出的地址，再思考一下 buddy system 分配内存的过程 这里输出的均为物理地址 预告 本章我们实现了内存分配，下一章我们学习管理已分配的内存的工具：页表。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/页表简介.html":{"url":"docs/页表简介.html","title":"6. 页表简介","keywords":"","body":"页表简介 本章代码对应分支：paging 概要 本章我们将介绍一种常见的内存管理方式：分页。页表是为了实现分页而创建的数据结构，直观来看，其功能就是将虚拟地址转换为物理地址。本章我们将学习： 什么是虚拟地址 什么是页表 RISC-V 32 的页表格式 在内核中创建最简单的页表 了解虚拟地址 操作系统的一个主要任务是将程序彼此隔离。比如，你在浏览网页时，并不应该干扰你的文本编辑器。而在编写浏览器或文本编辑器的时候，必然会需要对内存进行操作。然而编写文本编辑器的人也许并不认识编写浏览器的人。所以他们并不知道对方需要使用那部分的内存。 让我们先来看一个例子： fn main(){ let a: i32 = 5; // &a 先转成 raw 指针，然后再把指针转成 usize，这样就可以显示地址了。 let addr = &a as *const i32 as usize; println!(\"addr: 0x{:X}\",addr); } 编译运行上述代码，在我的电脑（64 位）中，输出的结果是 0x7FFCA26C5734，这里输出的地址叫做虚拟地址。在计算机真实访问内存的时候，并不会直接访问到变量的物理地址，而是先进行一个虚地址到物理地址的转换。可假想这个转换有一个函数，叫 fn virtual2physical(usize address) -> usize ，那么实际访问的内存则是： virtual2physical(0x7FFCA26C5734) 。 虚拟地址可能是不唯一的，但物理地址一定是唯一的。每一个线程可以拥有不同的虚实地址转换方法，所以 不同的虚拟地址可以转换成同一个物理地址；相同的虚拟地址可以转换成不同的物理地址 。 比如，这样，程序员在编写程序时，并不需要考虑内存冲突的问题，因为操作系统会给他分配一片“连续的虚拟内存”（即便他们的物理地址不一定连续）。 这段话看不懂没关系，以后学到了进程线程可能就懂了 页表简介 页表就是一个用于将虚拟地址转换为物理地址的工具。在 riscv32 中，如果 satp（Supervisor Address Translation and Protection，监管者地址转换和保护）寄存器的第 31 位为 1 ，则表示启用页表机制。在访问虚拟内存时（开启页表时只允许访问虚拟内存），内存管理单元 MMU(Memory Management Unit) 会用过页表将虚拟地址转换为物理地址，再进行访问， 分页技术的核心思想是将虚拟内存空间和物理内存空间视为固定大小的小块，虚拟内存空间的块称为 页面（pages） ，物理地址空间的块称为 帧（frames） ，每一个页都可以映射到一个帧上。 虚拟地址可以分为两部分， VPN（virtual page number） 和 page offset ： 虚拟地址的用法如下： 通过页表，将 VPN 转换为目标物理地址所处的页面 通过 page offset 在页面中找到具体的物理地址 riscv32 框架下，每个页面的大小为 4kb ，所以为了能够访问页面中的任意物理位置， page offset 的长度为 12 位。 2^12 byte = 4kb RISC-V 32 的页表格式 riscv32 框架采用了二级页表。一般来说，一个线程只有一个 页目录 ，不同的线程有不同的 页目录 （多个内核线程可以共用同一个页目录），所以对于不同的线程，相同的虚拟地址可以转换到不同的物理地址。页目录的每一项可能为空，也可能指向一个页表。 在 riscv32 中，物理地址是 34 位的： 虚拟地址是 32 位的，对于单个线程来说，其最多可使用的空间为 4G 。但是由于物理地址是 34 位的，所以整个系统可以包含多个线程，最大可用的内存为 16G 。 riscv32 中所有页面都是 4k 对齐的！！！ 因此任何页表所在地址的低 12 位一定是 0 。这使得我们在保存页表的地址的时候只需要保存其高 22 位（PPN）。 页目录 也是一个页面，可以理解为长度为 1024 的 u32 数组。每个 u32 就是一个页目录项，指向下一个页面。 riscv32 中， 页表项/页目录项 的结构是一样的，如下图所示： 虚实转换 页表中保存的地址均为物理地址，通过二级页表的地址虚实转换的过程如下： 通过页表，将 VPN 转换为目标物理地址所处的页面 通过 satp 获取页目录的基址(satp.PPN)。由于页目录的地址是 4k 对齐的，因此 satp.PPN （也可以写为 satp.PPN * PAGE_SIZE）就是页目录的所在的物理地址。 VPN[1] 给出了二级页号，因此处理器会读取位于地址 satp.PPN * PAGE_SIZE + VPN[1] * PTE_SIZE 的页目录项（page dir entry, pde）。 该 pde 包含一级页表的物理地址，VPN[0] 给出了一级页号，因此处理器读取位于地址 pde.PPN * PAGE_SIZE + VPN[0] * PTE_SIZE 的页表项（page table entry）。 通过 page offset 在页面中找到具体的物理地址 pte 的 PPN 字段和页内偏移（原始虚拟地址的低 12 位）组成了最终的物理地址：pte.PPN * PAGE_SIZE + page_offset 。 在 riscv32 中，PAGE_SIZE = 4096，PTE_SIZE = sizeof(u32) = 4 该过程可由下图表示。本文使用页表项（PTE）和页目录项（PDE）来区分一级页表和二级页表项，但是实际上他们的结构是相同的，所以图中将二者均写为 PTE 。左边的 PTE 为页目录项，右边的 PTE 为页表项。 页标志位 我们再来看一次 riscv32 中 页表项/页目录项 的结构： 如果 X, W, R 位均为 0 ，则表示该项包含了下一级页表的物理地址（为页目录项）。 否则表示该项包含了页面的物理地址（一般为页表项）。 RSW 域留给操作系统使用，它会被硬件（MMU）忽略，即虚实地址的转换与它无关，这里我们无需考虑 下面给出 XWR 位为不同值时表达的意思： X W R Meaning 0 0 0 Pointer to next level of page table 0 0 1 Read-only page 0 1 0 Reserved for future use 0 1 1 Read-write page 1 0 0 Execute-only page 1 0 1 Read-execute page 1 1 0 Reserved for future use 1 1 1 Read-write-execute page riscv 中， satp 寄存器的低 22 位保存了 页目录 的物理地址（类似于 X86 的 CR3 寄存器）。 大页 一般来说，页目录项保存的是指向下一个页表的地址的 PPN 和页标识位，且 XWR 均为 0 。但是，如果此时 XWR 不为 0 ，则其指向的是一片大小为 1024 * 4k = 4M 的物理地址，也称为 大页 。后面我们映射内核的时候就使用大页的映射方式。 线性映射 我们可以通过 satp 寄存器获得页目录的物理地址。但是如果我们开启了页机制，就不能再直接访问到物理地址。此时一种最简单的解决方案是：将全部物理内存区域映射到虚拟地址空间。此时虚拟地址和物理地址之间会有一种简单的对应关系，称为 线性映射 ，具体关系式如下： virtual address = physical address + offset 分页机制的实现 建立最简单的页表并开启分页 OpenSBI 并没有开启页机制，因此当我们 kernel 的第一条指令被执行的时候，是工作在物理地址上的。而当我们进入 Rust 代码后，运行栈上就已经保存了一些指针信息，此时再改变内核地址就会破坏运行时上下文。因此我们将切换地址空间的工作放在刚进入内核 S 态的汇编代码中完成。 为了方便起见，我们采用大页的映射方式，一次映射 4M 的空间。OpenSBI 将它自己放在 0x80000000 的位置，boot 结束后会跳转到 0x80400000（即我们编写的 os 的位置）。因此我们只需要映射 OpenSBI 所在的地址和我们的 os 所在的地址。 实际上 OpenSBI 是不需要映射的，因为 S 态不需要也不能访问 OpenSBI 的内存了。这里为了练习页表的使用也将其一起映射，在文章结尾处我们会代码，不再映射 OpenSBI ，并进行一些别的改动 首先修改 boot/entry.asm ，在其中定义第一个页表的内容： .section .data # 放在 data 段中，之后会修改内容 .align 12 # 4K 页对齐 boot_page_table_sv32: .zero 4 * 512 # 0x80000000 -> 0x80000000 (4M * 2) .word (0x80000 这个最简单的页表只包含一个页目录，占用 4K 空间。在其中我们对需要用到的地址空间建立 对等映射 ，即 虚拟地址 = 物理地址 。具体而言，这个页目录包含 1024 个页目录项，每一项对应 4M 大小的地址空间（全是大页）。 接下来我们计算建立对等映射时，应该修改哪一项页目录项： pageTableIndex(0x80000000) = 0x80000000.PPN[1] = 0x200 = 512 pageTableIndex(0x80400000) = 0x80400000.PPN[1] = 0x201 = 513 于是我们得出，需要映射的页目录项的下标为 512 和 513 ，他们分别对应 OpenSBI 和内核所在的物理地址空间： 区域 地址空间 PDX OpenSBI 0x80000000-0x80400000 (4M) 512 内核 0x80400000-0x80800000 (4M) 513 接下来我们看填入页表项的内容。（参考上面对页表项格式的定义）由于是对等映射，PPN 就是 0x80000 和 0x80400 。标志位我们填入 VRWXAD（0xcf），即映射到可读写可执行的大页。 .word (0x80000 其它项由于没有映射，直接填 0 即可。 在我们开启分页之前，先看一下管理分页的寄存器 satp 的结构： ASID(Address Space Identifier，地址空间标识符)域是可选的，它可以用来降低上下文切换的开销，这里我们直接填 0 这需要在 satp 寄存器中填入页目录的物理地址的 PPN ，并将最高位置为 1 ： _start: # 1. enable paging # satp = (1 lui t0, %hi(boot_page_table_sv32) 将 boot_page_table_sv32 的高 20 位复制到 t0 的高 20 位，t0 的第 12 位填 0 。右移 12 位后就正确的给 PPN 部分赋值了。 MPIS 与 RISCV 语法不同，%hi 的作用是取高 16 位 这时运行会出现 panicked at 'unexpected trap' ，这是由于在上一章我们“凭感觉”定了一个 KERNEL_HEAP_SIZE: usize = 0x00a0_0000 ，这一部分是被算入内核大小的。而在映射的时候，我们只映射了 4M 的内核地址，所以这个数字也需要相应进行修改，否则其余内核部分未被映射会导致内存访问错误。我们将其改小为 0x0010_0000 。 编译运行，应该能看到和之前相同的运行效果。 将内核移动到高地址空间 有了页表，我们就能改变内核运行时的虚拟地址了。传统的 Linux 操作系统中，在不使用 PTI（内核页表隔离）特性的情况下，内核和用户程序处于同一个地址空间（即使用同一个页表）。内核位于高地址空间，用户程序使用低地址空间。在 32 位系统中，这个界限一般是 0xC0000000，即内核使用最上面 1G 的空间，用户程序可用下面 3G 的空间。 接下来我们将内核的起始地址移动到 0xC0400000，即建立偏移为 0xC0400000 - 0x80400000 = 0x40000000 的线性映射。 在修改汇编代码之前，我们首先修改链接脚本 linker.ld ： - BASE_ADDRESS = 0x80400000; + BASE_ADDRESS = 0xC0400000; 由于修改了基址，相应的我们在计算可使用内存的时候用到的 end 也需要转换为物理地址： consts.rs + pub const KERNEL_OFFSET: usize = 0xC000_0000; memory/mod.rs - let memory_start = (end as usize) + PAGE_SIZE; + let memory_start = (end as usize - KERNEL_OFFSET + MEMORY_OFFSET) + PAGE_SIZE; 这样再次链接后的所有符号都移动到了新的地址上。注意 boot_page_table_sv32 是个符号，使用虚地址。而 satp 中需要填入物理地址。因此需要减去一个偏移。因此，我们还需要修改一下加载页目录地址的代码： # 1.1 enable paging # satp = (1 接下来修改一下页目录。首先，OpenSBI 所在内存不再需要被映射，然后将 0xC0400000 内存映射到 0x80400000 。注意，这里保留了 0x80400000 内存映射到 0x80400000 的对等映射： .section .data .align 12 boot_page_table_sv32: .zero 4 * 513 # 0x80400000 -> 0x80400000 (4M) .word (0x80400 0x80400000 (4M) .word (0x80400 pageTableIndex(0xC0400000) = 0xC0400000.PPN[1] = 0x301 = 769 = 513 + 1 + 255 之所以还要保留 0x80400000 的对等映射，是因为在开启分页的一瞬间，PC 仍然指向物理地址。如果撤掉了对等映射，那么在设置 satp 的下一条指令会立即触发缺页异常。我们需要一段同时存在两种映射的过渡期来切换 PC ，之后就可以取消这个对等映射。具体代码如下： # 1.2 update PC to 0xCxxxxxxx lui t0, %hi(remove_identity_map) addi t0, t0, %lo(remove_identity_map) jr t0 # 1.3 remove identity map remove_identity_map: lui t0, %hi(boot_page_table_sv32_top) sw zero, (-4 * 511)(t0) sfence.vma 我们使用绝对跳转指令来切换 PC ：首先定义一个符号 remove_identity_map，然后将其虚地址加载到寄存器 t0 ，最后使用 jr 指令跳转到 t0 指向的地址。 思考：为什么需要使用 boot_page_table_sv32_top 而非 boot_page_table_sv32 访问页目录？ 提示：立即数偏移范围是 [-2048, 2047] 现在 PC 已经指向位于 0xC0000000 区域的虚拟地址空间，就可以撤销对等映射了：我们向下标为 513 的页表项地址处写入 0，然后执行 sfence.vma 刷新 TLB。 再次编译运行，应该可以正常进入 Rust 代码。此时如果打印一个指针，就可以看到它们的地址已经变成了 0xC04xxxxx 。 处理缺页异常 当开启页机制后，如果程序访问没有映射的虚拟地址，或者访问权限不正确，就会触发缺页异常（Page Fault）。 我们之前已经建立好了中断处理函数 rust_trap，可以直接在其中进行处理。首先新建一个处理缺页的函数，输出原因和错误地址： fn page_fault(tf: &mut TrapFrame) { println!(\"{:?} @ {:#x}\", tf.scause.cause(), tf.stval); panic!(\"page fault\"); } 然后在 rust_trap 中检查异常类型并转发到此函数： #[no_mangle] pub extern \"C\" fn rust_trap(tf: &mut TrapFrame) { match tf.scause.cause() { Trap::Exception(Exception::Breakpoint) => breakpoint(), Trap::Interrupt(Interrupt::SupervisorTimer) => timer(), Trap::Exception(Exception::InstructionPageFault) => page_fault(tf), Trap::Exception(Exception::LoadPageFault) => page_fault(tf), Trap::Exception(Exception::StorePageFault) => page_fault(tf), _ => panic!(\"unexpected trap: {:#x?}\", tf), } } 接着我们在主函数中进行测试： 读取一下内核的第一条指令 访问一个没有映射的非法地址 fn test_page_table() { // test read let ptr = 0xc0400000 as *const u32; let value = unsafe { ptr.read() }; println!(\"addr: {:?}, value: {:#x}\", ptr, value); // test write: page fault! unsafe { (0xc0000000 as *mut u32).write(0); } } 编译运行，结果如下所示： addr: 0xc0400000, value: 0xc040c2b7 Exception(StorePageFault) @ 0xc0000000 panicked at 'page fault', src/interrupt.rs:49:5 我们用 make asm 查看一下内核的反汇编： Disassembly of section .text: c0400000 : c0400000: c040c2b7 lui t0,0xc040c c0400004: 40000337 lui t1,0x40000 c0400008: 406282b3 sub t0,t0,t1 ... 可以看到程序读取到的第一条指令是正确的。并且之后正确触发了缺页异常。 预告 现在我们已经有了一个可使用的页表了，但是它的功能还十分有限。后续我们将实现功能更加强大的页表。但是目前它已经够用了。下一章我们将创建内核线程。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/内核线程.html":{"url":"docs/内核线程.html","title":"7. 内核线程","keywords":"","body":"实现内核线程 本章代码对应分支：thread 概要 内核可以看作一个服务线程，管理软硬件资源，响应用户线程的种种合理以及不合理的请求。为了防止可能的阻塞，支持多线程是必要的。内核线程就是内核的分身，一个分身可以处理一件特定事情。内核线程的调度由内核负责，一个内核线程处于阻塞状态时不影响其他的内核线程。本章我们的任务有： 实现内核线程相关结构体。 为新线程构造这个结构体。 实现线程切换。 线程相关结构体 创建 process/structs.rs ，并在 lib.rs 中加入 mod process 。 描述一个线程，需要知道其全部的寄存器信息以及栈的使用情况： process/structs.rs use crate::context::Context; pub struct Thread { pub context: Context, // 线程相关的上下文 pub kstack: KernelStack, // 线程对应的内核栈 } 在切换线程时，我们会将上下文直接保存在栈上，因此 Context 只需要保存最终的栈指针 sp，也就是上下文的起始地址 content_addr 即可，详细的上下文内容使用新的结构体 ContextContent 描述。与 Trap 章节创建的栈帧结构的方式类似，我们需要一个规定好格式的结构体来读取寄存器的内容（具体的保存过程仍然需要用过汇编代码保存）： context.rs #[repr(C)] pub struct Context { content_addr: usize // 上下文内容存储的位置 } #[repr(C)] struct ContextContent { ra: usize, // 返回地址 satp: usize, //　二级页表所在位置 s: [usize; 12], // 被调用者保存的寄存器 } 复读：其中 #[repr(C)] 表示对这个结构体按 C 语言标准 进行内存布局，也就是从起始地址开始，按字段的定义顺序依次排列。如果不写的话，Rust 对它的内存布局是不确定的，会导致我们无法使用汇编代码对它进行正确的读写。 在发生函数调用时， riscv32 约定了 调用者保存寄存器（caller saved） 和 被调用者保存寄存器（callee saved） ，保存前者的代码由编译器悄悄的帮我们生成，保存后者的代码则需要我们自己编写，所以结构体中只包含部分寄存器。 接下来我们定义 内核栈（KernelStack） 的结构： structs.rs pub struct KernelStack(usize); const STACK_SIZE: usize = 0x8000; 其实内核栈保存了该内核线程的各种数据以及上下文内容，本质上它就是一片固定大小的内存空间，因此我们只需要在 KernelStack 中记录栈的起始地址。 为了实现简单，栈空间就直接从内核堆中分配了。我们需要在它的构造函数（new）中分配内存，并在析构函数（Drop）中回收内存。具体而言，我们使用 rust 的 alloc API 实现内存分配和回收： lib.rs #![feature(alloc)] process/struct.rs extern crate alloc; use alloc::alloc::{alloc, dealloc, Layout}; impl KernelStack { pub fn new() -> KernelStack { let bottom = unsafe { alloc(Layout::from_size_align(STACK_SIZE, STACK_SIZE).unwrap()) } as usize; KernelStack(bottom) } pub fn top(&self) -> usize { self.0 + STACK_SIZE } } impl Drop for KernelStack { fn drop(&mut self) { unsafe { dealloc( self.0 as _, Layout::from_size_align(STACK_SIZE, STACK_SIZE).unwrap() ); } } } Drop trait 包含在 prelode 中，所以无需手动引入他。 为新线程构造结构体 在操作系统中，有一个特殊的线程，其名字为为 idle 。其作用是初始化一些信息，并且在没有其他线程需要运行的时候运行他。为此我们需要对这个特殊的内核线程和内核其他的线程进行一些区分： process/structs.rs use riscv::register::satp; impl Thread { pub fn new_idle() -> Thread { unsafe { Thread { context: Context::null(), kstack: KernelStack::new(), } } } pub fn new_kernel(entry: extern \"C\" fn(usize) -> !, arg: usize) -> Thread { unsafe { let kstack_ = KernelStack::new(); Thread { context: Context::new_kernel_thread(entry, arg, kstack_.top(), satp::read().bits()), kstack: kstack_, } } } } 内核线程的 kstack 除了存放线程运行需要使用的内容，还需要存放 ContextContent 。因此在创建 Thread 的时候，需要为其分配 kstack ，将 ContextContext 内容复制到 kstack 的 top 。而 Context 只保存 ContextContent 首地址 content_addr ： context.rs Context 的构造函数： impl Context { pub unsafe fn null() -> Context { Context { content_addr: 0 } } pub unsafe fn new_kernel_thread( entry: extern \"C\" fn(usize) -> !, arg: usize, kstack_top: usize, satp: usize ) -> Context { ContextContent::new_kernel_thread(entry, arg, kstack_top, satp).push_at(kstack_top) } } idle 线程的 content_addr 赋值为 0 的原因稍后说明 ContextContent 的构造函数： use core::mem::zeroed; use riscv::register::sstatus; impl ContextContent { fn new_kernel_thread(entry: extern \"C\" fn(usize) -> !, arg: usize , kstack_top: usize, satp: usize) -> ContextContent { let mut content: ContextContent = unsafe { zeroed() }; content.ra = entry as usize; content.satp = satp; content.s[0] = arg; let mut sstatus_ = sstatus::read(); sstatus_.set_spp(sstatus::SPP::Supervisor); // 代表 sret 之后的特权级仍为 S content.s[1] = sstatus_.bits(); content } unsafe fn push_at(self, stack_top: usize) -> Context { let ptr = (stack_top as *mut ContextContent).sub(1); *ptr = self; // 拷贝 ContextContent Context { content_addr: ptr as usize } } } 新线程的 s0 暂时没用，所以用他来暂存参数 arg ，稍后通过汇编代码将 a0 赋值为 s0 。 sret 之后的权限模式和中断状态由 sstatus 控制，这一步 content.ra = entry as usize 指定跳转地址。 线程切换 创建好线程之后，则需要有办法能够在多个线程中相互切换。 线程切换 也叫 上下文切换 。切换的过程需要两步： 保存当前寄存器状态。 加载另一线程的寄存器状态。 process/structs.rs impl Thread { pub fn switch_to(&mut self, target: &mut Thread) { unsafe { self.context.switch(&mut target.context); } } } lib.rs #![feature(naked_functions)] context.rs impl Context { #[naked] #[inline(never)] pub unsafe extern \"C\" fn switch(&mut self, target: &mut Context) { asm!(include_str!(\"process/switch.asm\") :::: \"volatile\"); } } 由于我们要完全手写汇编实现 switch 函数，因此需要给编译器一些特殊标记： #[inline(never)] 表示禁止函数内联。这是由于我们需要 ret 和 ra 寄存器控制切换线程。如果内联了就没有 ret ，也就无法实现线程切换了。 #[naked] 标签表示不希望编译器产生多余的汇编代码。这里最重要的是 extern \"C\" 修饰，这表示该函数使用 C 语言的 ABI ，所以规范中所有调用者保存的寄存器（caller-saved）都会保存在栈上。 至此，我们只剩下最后一个任务：编写 switch 的过程 ： process/switch.asm .equ XLENB, 4 .macro Load reg, mem lw \\reg, \\mem .endm .macro Store reg, mem sw \\reg, \\mem .endm addi sp, sp, (-XLENB*14) Store sp, 0(a0) Store ra, 0*XLENB(sp) Store s0, 2*XLENB(sp) Store s1, 3*XLENB(sp) Store s2, 4*XLENB(sp) Store s3, 5*XLENB(sp) Store s4, 6*XLENB(sp) Store s5, 7*XLENB(sp) Store s6, 8*XLENB(sp) Store s7, 9*XLENB(sp) Store s8, 10*XLENB(sp) Store s9, 11*XLENB(sp) Store s10, 12*XLENB(sp) Store s11, 13*XLENB(sp) csrr s11, satp Store s11, 1*XLENB(sp) Load sp, 0(a1) Load s11, 1*XLENB(sp) csrw satp, s11 Load ra, 0*XLENB(sp) Load s0, 2*XLENB(sp) Load s1, 3*XLENB(sp) Load s2, 4*XLENB(sp) Load s3, 5*XLENB(sp) Load s4, 6*XLENB(sp) Load s5, 7*XLENB(sp) Load s6, 8*XLENB(sp) Load s7, 9*XLENB(sp) Load s8, 10*XLENB(sp) Load s9, 11*XLENB(sp) Load s10, 12*XLENB(sp) Load s11, 13*XLENB(sp) mv a0, s0 addi sp, sp, (XLENB*14) Store zero, 0(a1) ret Store sp, 0(a0) 将用于保存上下文地址的 content_addr 赋值给 sp ，然后在 sp 指向的位置保存 callee saved 寄存器。保存完毕后通过 Load sp, 0(a1) 将目标线程的 content_addr 赋值给 sp ，然后恢复目标线程的寄存器。 mv a0, s0 用于传入新线程的参数。 对于新创建的线程，因为没有 caller 为其保存 caller-saved ，所以 s0 给 a0 赋的值可以被保留下来。而对于就旧线程， a0 将被恢复为 caller saved 中的值，不受 s0 的影响； sstatus 同理。 最后创建 idle 线程和 hello 线程，然后进行切换： process/mod.rs mod structs; use structs::Thread; pub fn init() { let mut loop_thread = Thread::new_idle(); let mut hello_thread = Thread::new_kernel(hello_thread, 666); loop_thread.switch_to(&mut hello_thread); } #[no_mangle] pub extern \"C\" fn hello_thread(arg: usize) -> ! { println!(\"hello thread\"); println!(\"arg is {}\", arg); loop{ } } init.rs #[no_mangle] pub extern \"C\" fn rust_main(hartid: usize, dtb: usize) -> ! { ... crate::process::init(); loop {} } 执行 make run ，屏幕打印出： hello thread arg is 666 100 ticks! 100 ticks! ... 表示我们已经成功创建并切换至 hello_thread 。 预告 现在我们已经可以正确的切换内核线程，但是线程切换过去之后就再也没有回到 idle 线程了。而这就是我们下一章的任务：线程调度。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/线程调度.html":{"url":"docs/线程调度.html","title":"8. 线程调度","keywords":"","body":"实现线程调度 本章代码对应 commit ：65ccec7b180cd56e645f359343a793e75a49eb98 概要 多线程并发执行需要调度器的辅助。调度器的作用是在合适的时刻选择线程执行，并在合适的时候切换线程，防止一个线程占用或多的资源或阻塞，从而实现 cpu 资源分配相对“公平”。本章我们将： 假想我们已经有了一个调度算法。 算法和数据结构是分离的，所以在实现调度器的时候不依赖于算法 创建线程池（thread pool）用于保存所有线程。 创建线程管理器（processor）通过调度算法管理 thread pool。 实现线程调度相关函数。 引入 Round Robin 调度算法。 调度算法 //in process/scheduler.rs impl Scheduler { pub fn new(max_time_slice: usize) -> Scheduler { /* TODO */ } pub fn push(&mut self, tid: Tid) { /* TODO */ } pub fn pop(&mut self) -> Option { /* TODO */ } pub fn tick(&mut self) -> bool { /* TODO */ } pub fn exit(&mut self, tid: Tid) { /* TODO */ } } 这是本章我们使用的调度算法的对外接口。功能包括创建（new）、添加线程（push）、获取即将被调用的线程（pop）、提醒算法时钟周期的到来（tick）和退出线程时将线程从调度算法中移出（exit）。 线程池（ThreadPool） 线程的运行状态包括但不限于：等待运行、运行中、睡眠和等待退出。这里我们创建一个枚举类型作为进程的状态类型： // in process/mod.rs pub type Tid = usize; pub type ExitCode = usize; // in process/structs.rs use crate::process::{ Tid, ExitCode }; #[derive(Clone)] pub enum Status { Ready, Running(Tid), Sleeping, Exited(ExitCode), } Tid 是线程 id 。就像每个人的身份证号都是不一样的，每一个线程都有独一无二的 id ，这时线程的标识。 线程池是用于存放线程的容器，只需要包含线程的信息和线程调度算法。创建 process/thread_pool.rs ： // in process/thread_pool.rs use crate::process::scheduler::Scheduler; use crate::process::structs::*; use alloc::{ vec::Vec, boxed::Box }; struct ThreadInfo { status: Status, present: bool, thread: Option>, } pub struct ThreadPool { threads: Vec>, // 线程信号量的向量 scheduler: Box, // 调度算法 } Box 允许我们将一个值放在堆上而不是栈上，留在栈上的则是指向堆数据的指针。除了数据被储存在堆上而不是栈上之外，Box 没有额外的性能损失，不过也没有额外的功能。 让我们先来实现他的构造函数和向线程池中加入线程的功能： // in process/thread_pool.rs use crate::process::Tid; impl ThreadPool { pub fn new(size: usize, scheduler: Scheduler) -> ThreadPool { ThreadPool { threads: { let mut th = Vec::new(); th.resize_with(size, Default::default); th }, scheduler: Box::new(scheduler), } } fn alloc_tid(&self) -> Tid { for (i, info) in self.threads.iter().enumerate() { if info.is_none() { return i; } } panic!(\"alloc tid failed !\"); } pub fn add(&mut self, _thread: Box) { let tid = self.alloc_tid(); self.threads[tid] = Some(ThreadInfo{ status: Status::Ready, present: true, thread: Some(_thread), }); self.scheduler.push(tid); println!(\"tid to alloc: {}\", tid); } } 构造函数规定了线程的最大数量 size 和调度算法。由于线程数组是已经创建好的，但是默认内容为 None ，所以在添加线程的时候只需要将从 Vec 中找到一个未使用的位置，把新线程的信息传递过去就可以了。同时，不要忘记为调度算法传入线程 id 。 调度器 由于创建的调度器是全局的，需要考虑一些安全问题和异步问题。为此需要对成员进行一些包装，不过这不影响实现思路。创建 processor.rs ： // in process/processor.rs use core::cell::UnsafeCell; use alloc::boxed::Box; use crate::process::Tid; use crate::process::structs::*; use crate::process::thread_pool::ThreadPool; pub struct ProcessorInner { pool: Box, idle: Box, current: Option)>, } pub struct Processor { inner: UnsafeCell>, } unsafe impl Sync for Processor {} 一个实现了 Sync trait 的类型可以安全的在多个线程中拥有其值的引用。因为他是标记 trait ，所以不需要手动实现。 UnsafeCell 内的元素不严格区分 immutable 和 mutable 。 调度器接口实现 这里先列出功能简单明了的几个函数： // in process/processor.rs impl Processor { pub const fn new() -> Processor { Processor { inner: UnsafeCell::new(None), } } pub fn init(&self, idle: Box, pool: Box ) { unsafe { *self.inner.get() = Some(ProcessorInner{ pool, idle, current: None, }); } } fn inner(&self) -> &mut ProcessorInner { unsafe { &mut *self.inner.get() } .as_mut() .expect(\"Processor is not initialized\") } pub fn add_thread(&self, thread: Box) { self.inner().pool.add(thread); } } 在进行线程切换时，为了防止因为中断引起线程切换出错，需要关闭中断，之后再恢复到原先的中断状态。这里我们先实现三个与中断控制相关的函数： // in interrupt.rs #[inline(always)] pub fn enable_and_wfi() { // 使能中断并等待中断 unsafe { asm!(\"csrsi sstatus, 1 usize { // 禁用中断并返回当前中断状态 let sstatus: usize; unsafe { asm!(\"csrci sstatus, 1 接下来开始实现三个与调度直接相关的重要函数。 其中调用了一些 ThreadPool 中尚未实现的函数，将于之后实现 run 这是整个调度过程最核心的函数，由 idle 线程调用。具体实现如下： // in process/processor.rs use crate::interrupt::{ disable_and_store, enable_and_wfi }; impl Processor { pub fn run(&self) -> !{ let inner = self.inner(); // 关闭中断，防止此时产生中断异常导致线程切换出错。 disable_and_store(); // 循环从线程池中寻找可调度线程 loop { // 如果存在需要被调度的线程 if let Some(thread) = inner.pool.acquire() { inner.current = Some(thread); // 切换至需要被调度的线程 inner.idle.switch_to(&mut *inner.current.as_mut().unwrap().1); // 上一个线程已经结束或时间片用完，切换回 idle 线程 let (tid, thread) = inner.current.take().unwrap(); println!(\"thread {} ran just now\", tid); // 将上一个线程放回线程池中 inner.pool.retrieve(tid, thread); } else { // 开启中断并等待中断产生 enable_and_wfi(); // 关闭中断，从线程池中寻找可调度线程 disable_and_store(); } } } } tick 每产生一次时钟中断（即经过一个时钟周期），就需要通知线程池，让他通过调度算法判断是否需要切换线程： // in process/mod.rs static CPU: Processor = Processor::new(); pub fn tick() { CPU.tick(); } // in interrupt.rs use crate::process::tick; fn super_timer() { clock_set_next_event(); unsafe{ TICK = TICK + 1; if TICK % 100 == 0 { println!(\"100 ticks!\"); } } tick(); } // in process/processor.rs use crate::interrupt::restore; impl Processor { pub fn tick(&self) { let inner = self.inner(); if !inner.current.is_none() { if inner.pool.tick() { let flags = disable_and_store(); inner .current .as_mut() .unwrap() .1 .switch_to(&mut inner.idle); // 恢复原先的中断状态 restore(flags); } } } } inner.pool.tick 会通知线程池和调度算法已经过了一个时钟周期，同时返回一个布尔值：是否需要进行线程切换。如果需要切换至其他线程，则先切换至 idle 线程，然后由 idle 进行调度（回到 Processer.run）。 exit 当线程任务完成之后，就可以通过 Processor.exit 结束自己（结束当前线程）： // in process/processor.rs impl Processor { pub fn exit(&self, code: usize) -> ! { let inner = self.inner(); let tid = inner.current.as_ref().unwrap().0; // 通知线程池该线程即将退出 inner.pool.exit(tid, code); // 切换至 idle 线程，进入调度 inner .current .as_mut() .unwrap() .1 .switch_to(&mut inner.idle); loop {} } } 线程池接口实现 线程池接口的功能在前文已经提及，也可由函数名判断函数功能。具体实现也较为简单，所以直接给出实现： // in process/thread_pool.rs impl ThreadPool { pub fn acquire(&mut self) -> Option)> { if let Some(tid) = self.scheduler.pop() { let mut thread_info = self.threads[tid].as_mut().expect(\"thread not exist !\"); thread_info.status = Status::Running(tid); return Some((tid, thread_info.thread.take().expect(\"thread not exist \"))); } else { return None; } } pub fn retrieve(&mut self, tid: Tid, thread: Box ) { let mut thread_info = self.threads[tid].as_mut().expect(\"thread not exist !\"); if thread_info.present { thread_info.thread = Some(thread); thread_info.status = Status::Ready; self.scheduler.push(tid); } } pub fn tick(&mut self) -> bool { // 通知调度算法时钟周期加一，询问是否需要调度 self.scheduler.tick() } pub fn exit(&mut self, tid: Tid, code: usize) { self.threads[tid] = Some(ThreadInfo{ status: Status::Ready, present: false, thread: None, }); self.scheduler.exit(tid); println!(\"exit code: {}\", code); } } 这里用到了 Option.take ，功能与所有权转移或浅拷贝相似 引入 Round Robin 调度算法 在 Cargo.toml 中加入： RoundRobinScheduler = { path = \"crate/RoundRobinScheduler\" } 创建 process/scheduler.rs ： use crate::process::Tid; use RoundRobinScheduler::RRScheduler; pub struct Scheduler { scheduler: RRScheduler, } impl Scheduler { pub fn new(max_time_slice: usize) -> Scheduler { let s = Scheduler { scheduler: RRScheduler::new(max_time_slice), }; s } pub fn push(&mut self, tid: Tid) { self.scheduler.push(tid); } pub fn pop(&mut self) -> Option { self.scheduler.pop() } pub fn tick(&mut self) -> bool { self.scheduler.tick() } pub fn exit(&mut self, tid: Tid) { self.scheduler.exit(tid); } } 最后，由于 Processor.add_thread 需要 Box 类型的参数，所以我们修改一下 struct Thread 的构造函数： // in process/structs.rs use alloc::boxed::Box; use riscv::register::satp; impl Thread { pub fn new_idle() -> Box { unsafe { Box::new(Thread { context: Context::null(), kstack: KernelStack::new(), }) } } pub fn new_kernel(entry: extern \"C\" fn(usize) -> !, arg: usize) -> Box { unsafe { let _kstack = KernelStack::new(); Box::new(Thread { context: Context::new_kernel_thread(entry, arg, _kstack.top(), satp::read().bits()), kstack: _kstack, }) } } } 至此我们的调度器已经全部完成，让我们来测试一下他吧： // in process/mod.rs mod structs; mod scheduler; mod processor; mod thread_pool; use structs::Thread; use alloc::boxed::Box; use processor::Processor; use thread_pool::ThreadPool; use self::scheduler::Scheduler; pub type Tid = usize; pub type ExitCode = usize; static CPU: Processor = Processor::new(); pub fn tick() { CPU.tick(); } pub fn init() { println!(\"+------ now to initialize process ------+\"); let scheduler = Scheduler::new(1); let thread_pool = ThreadPool::new(100, scheduler); CPU.init(Thread::new_idle(), Box::new(thread_pool)); let thread0 = Thread::new_kernel(hello_thread, 0); CPU.add_thread(thread0); let thread1 = Thread::new_kernel(hello_thread, 1); CPU.add_thread(thread1); let thread2 = Thread::new_kernel(hello_thread, 2); CPU.add_thread(thread2); let thread3 = Thread::new_kernel(hello_thread, 3); CPU.add_thread(thread3); let thread4 = Thread::new_kernel(hello_thread, 4); CPU.add_thread(thread4); CPU.run(); } #[no_mangle] pub extern \"C\" fn hello_thread(arg: usize) -> ! { println!(\"hello thread\"); println!(\"arg is {}\", arg); for i in 0..100 { println!(\"{}{}{}{}{}{}{}{}\", arg, arg, arg, arg, arg, arg, arg, arg); for j in 0..1000 { } } println!(\"end of thread {}\", arg); CPU.exit(0) } FIX runtime error: panicked at 'Processor is not initialized' 执行 make run ，发现kernel出现了运行时错误： ... kernel_end:0x80c01000: kernel_size:0xc01000 +------ now to initialize process ------+ panicked at 'Processor is not initialized', /home/chyyuu/.rustup/toolchains/nightly-2019-03-05-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore/option.rs:1038:5 qemu-system-riscv32: terminating on signal 15 from pid 31872 () 从字面意思上看，是Processor这个结构没有初始化！但仔细检查代码，在如下代码中有new和记忆棒初始化的过程： // in process/mod.rs ... static CPU: Processor = Processor::new(); pub fn init() { println!(\"+------ now to initialize process ------+\"); let scheduler = Scheduler::new(1); let thread_pool = ThreadPool::new(100, scheduler); println!(\"+------ now to initialize processor ------+\"); CPU.init(Thread::new_idle(), Box::new(thread_pool)); ... 所以，不应该是这部分的问题。再进一步检查，在init.rs中的rust_main函数在调用process_init()之前，有一些unsafe代码，怀疑是它造成的？？？。试着把代码删除。再执行 make run ，发现我们的调度器已经能够自动切换线程，线程来回切换也可以正常恢复原先的工作环境，并且在线程结束后能够正常结束退出。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/创建页表.html":{"url":"docs/创建页表.html","title":"9. 创建页表","keywords":"","body":"实现页表 本章代码对应 commit ：f34aba219f9a336d0bad562f217d62d8bf2e38a6 概要 上一章我们通过 bbl 启用了分页机制。但是这个由于这个页表过于简陋，所以我们希望能够使用自己写的页表。 bbl 中创建的页表其实并不完善，所以本章我们将自己动手建立页表（remap kernel）。这个过程分为以下几步： 获取需要重新映射的内存范围（虚拟地址）。 设置页面属性。 设置页表，将虚拟地址映射至目标物理地址。 重新映射范围 首先我们需要获取需要重新映射内存的虚拟地址范围： // in memory/mod.rs extern \"C\" { // text fn stext(); fn etext(); // data fn sdata(); fn edata(); // read only fn srodata(); fn erodata(); // bss fn sbss(); fn ebss(); // kernel fn start(); fn end(); // boot fn bootstack(); fn bootstacktop(); } 这些函数赋值由 boot/linker.ld 完成，这里将他们作为 usize 使用。 设置页面属性 首先，创建文件 memory/paging.rs 。然后修改 memory/mod.rs ： // in memory/mod.rs mod paging; pub fn init(dtb: usize) { ... remap_kernel(dtb); } fn remap_kernel(dtb: usize) { println!(\"remaping\"); let offset = KERNEL_OFFSET as usize - MEMORY_OFFSET as usize; use crate::memory::paging::{ InactivePageTable, MemoryAttr }; let mut pg_table = InactivePageTable::new(offset); pg_table.set(stext as usize, etext as usize, MemoryAttr::new().set_readonly().set_execute()); pg_table.set(sdata as usize, edata as usize, MemoryAttr::new().set_WR()); pg_table.set(srodata as usize, erodata as usize, MemoryAttr::new().set_readonly()); pg_table.set(sbss as usize, ebss as usize, MemoryAttr::new().set_WR()); pg_table.set(bootstack as usize, bootstacktop as usize, MemoryAttr::new().set_WR()); pg_table.set(dtb, dtb + MAX_DTB_SIZE, MemoryAttr::new().set_WR()); unsafe { pg_table.activate(); } } 这里涉及了两个尚未创建的结构体，首先我们来实现 MemoryAttr 。在 页表简介 中我们介绍过 页表项/页目录项 的结构，我们只需要根据其结构设置相关属性即可： // in memory/paging.rs pub struct MemoryAttr(u32); impl MemoryAttr { pub fn new() -> MemoryAttr { MemoryAttr(1) } pub fn set_readonly(mut self) -> MemoryAttr { self.0 = self.0 | 2; // 1 MemoryAttr { self.0 = self.0 | 8; // 1 MemoryAttr { self.0 = self.0 | 2 | 4; self } } 由于我们创建的页表需要是有效（valid）的，所以 new 函数中使用 1 进行初始化 页表结构体 // in memory/paging.rs use riscv::addr::Frame; use crate::memory::frame_allocator::alloc_frame; pub struct InactivePageTable { root_table: Frame, PDEs: [Option; 1024], offset: usize, } 该结构体包含了根页表的物理地址，根页表的页目录项。由于我们采用线性映射，所以我们还需要保存线性映射的 offset 。 // in memory/paging.rs impl InactivePageTable { pub fn new(_offset: usize) -> InactivePageTable { if let Some(_root_table) = alloc_frame() { return InactivePageTable { root_table: _root_table, PDEs: [None; 1024], offset: _offset, } } else { panic!(\"oom\"); } } } 首先我们给根页表分配一个页面大小的物理内存，以后可以作为长度为 1024 的 u32 数组使用。每个 u32 就是一个页目录项。 PDEs 为页目录项指向的页表的物理地址，用 None 初始化。 地址虚实转换 页面重新映射的过程与虚拟地址通过页表转换为物理地址的过程相似，我们先通过图示看看虚拟地址转换为物理地址的过程： 通过 satp 获取根页表（页目录）的基址(satp.PPN)，VPN[1]给出了二级页号，因此处理器会读取位于地址 satp.PPN * PAGE_SIZE + VPN[1] * PTE_SIZE 的页目录项（pde）。 该 pde 包含一级页表的物理地址，VPN[0]给出了一级页号，因此处理器读取位于地址 pde.PPN * PAGE_SIZE + VPN[0] * PTE_SIZE 的页表项(pte)。 pte 的 PPN 字段和页内偏移（原始虚拟地址的低 12 位）组成了最终的物理地址：pte.PPN * PAGE_SIZE + page_offset 。 在 riscv32 中，PAGE_SIZE = 4096，PTE_SIZE = sizeof(u32) = 4 该过程可由下图表示。本文使用页表项（PTE）和页目录项（PDE）来区分一级页表和二级页表项，但是实际上他们的结构是相同的，所以图中将二者均写为 PTE 。左边的 PTE 为二级页表项，右边的 PTE 为一级页表项。 注意，物理地址长度为 34 ，而虚拟地址长度为 32 为了获取 VPN[1] 和 VPN[0] 编写以下函数： fn get_PDX(addr: usize) -> usize { addr >> 22 } fn get_PTX(addr: usize) -> usize { (addr >> 12) & 0x3ff } 页面重映射 地址虚实转换过程编写页面的重新映射： impl InactivePageTable { fn pgtable_paddr(&mut self) -> usize { self.root_table.start_address().as_usize() } fn pgtable_vaddr(&mut self) -> usize { self.pgtable_paddr() + self.offset } pub fn set(&mut self, start: usize, end: usize, attr: MemoryAttr) { unsafe { let mut vaddr = start & !0xfff; // 4K 对齐 let pg_table = &mut *(self.pgtable_vaddr() as *mut [u32; 1024]); while vaddr > 12; pg_table[PDX] = (PDE_PPN > 2) as u32 | attr.0; vaddr += (1 映射的过程已写于注释中，这里不再赘述。 最后，让我们来完成启用页表的函数： use riscv::asm::sfence_vma_all; impl InactivePageTable { unsafe fn set_root_table(root_table: usize) { // 设置satp asm!(\"csrw satp, $0\" :: \"r\"(root_table) :: \"volatile\"); } unsafe fn flush_tlb() { sfence_vma_all(); } pub unsafe fn activate(&mut self) { Self::set_root_table((self.pgtable_paddr() >> 12) | (1 这里我们通过将新页表的物理地址写入 satp 寄存器，达到切换页表的目的。tlb 可以理解为页表的缓存，用以加快虚拟地址转换为物理地址的速度。所以在切换页表之后需要通过 flush_tlb 清空缓存。 执行 make run ，屏幕正常而规律的输出着 100 ticks! 。虽然看起来与之前并无不同，但这依然是一件令人感到兴奋的事情。 没出 bug 难道不是一件值得兴奋的实现吗。。。 预告 多线程并发技术使得计算机能够“同时”执行多个线程，从而提升整体性能。下一章我们将实现内核线程的创建，并完成线程的切换。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/用户进程.html":{"url":"docs/用户进程.html","title":"10. 用户进程","keywords":"","body":"用户进程 本章代码对应 commit ：825c1d6cd68da8a99b6b1bee81c25b78cc08dacd 由于本人水平有限，在写用户进程的时候页表炸了；且 ddl 在即，所以把学长写的页表抄了过来，用于后续用户进程和文件系统的实现。。。有时间了（暑假或者下学期）我再填这个坑 可支持用户进程的页表 所以首先我们来抄页表 不想抄的话我这里也做了一个 commit: f6e9d1603d0949dd2187e873ec38307e7d3c1f56 ，直接在这个 commit 的基础上实现本章的内容也行 首先，把 bbl.c 里的 static void setup_page_table_sv32 函数改回来： static void setup_page_table_sv32() { // map kernel [0x300..] 0x80000000 -> 0xC0000000.. int i_end = dtb_output() / MEGAPAGE_SIZE; for (int i = 0x200; i > RISCV_PGSHIFT; root_table[0x3fd] = pte_create(root_table_ppn, 0); root_table[0x3fe] = pte_create(root_table_ppn, PTE_R | PTE_W); } 然后下载一下学长写的页表 创建 memory_set 目录，加入 这些文件 ，然后在 lib.rs 中加入 mod memory_set 。 paging.rs 内容全删掉，换成 这个 consts.rs 里加上 pub const RECURSIVE_INDEX: usize = 0x3fd ，页表 最后，把 memory/mod.rs 里的 mod paging 改为 pub mod paging ，然后把 remap_kernel 改为： fn remap_kernel(dtb: usize) { let offset = - ( KERNEL_OFFSET as isize - MEMORY_OFFSET as isize); use crate::memory_set::{ MemorySet, handler::Linear, attr::MemoryAttr }; let mut memset = MemorySet::new(); memset.push( stext as usize, etext as usize, MemoryAttr::new().set_execute().set_readonly(), Linear::new(offset), ); memset.push( srodata as usize, erodata as usize, MemoryAttr::new().set_readonly(), Linear::new(offset), ); memset.push( sdata as usize, edata as usize, MemoryAttr::new(), Linear::new(offset), ); memset.push( bootstack as usize, bootstacktop as usize, MemoryAttr::new(), Linear::new(offset), ); memset.push( sbss as usize, ebss as usize, MemoryAttr::new(), Linear::new(offset), ); memset.push( dtb as usize, dtb as usize + MAX_DTB_SIZE, MemoryAttr::new(), Linear::new(offset), ); unsafe{ memset.activate(); } } 执行一下 make run ，输出结果和之前是一样的。。。 wohaocaia 实现用户进程 用户程序 动态的添加用户程序是我们所期望的，但是由于缺少文件系统，本章将用户程序直接编译进内核。 下一章将支持动态执行用户程序 首先，创建目录 usr ，执行 cargo new rust --bin --edition 2018 将自动生成的 main.rs 放入 usr/rust/src/bin 目录下（需要创建），然后修改为： #![no_std] #![no_main] #[macro_use] extern crate rust; #[no_mangle] pub fn main() { for i in 0..100 { println!(\"Hello, world!\"); for j in 0..1000 { } } println!(\"Hello, world!\"); } 本章我们需要实现两个 syscall: SYS_WRITE, SYS_EXIT 。 创建 usr/rust/src/syscall.rs ： #[inline(always)] fn sys_call( syscall_id: SyscallId, arg0: usize, arg1: usize, arg2: usize, arg3: usize, ) -> i32 { let id = syscall_id as usize; let mut ret: i32; unsafe { asm!(\"ecall\" : \"={x10}\" (ret) : \"{x17}\" (id), \"{x10}\" (arg0), \"{x11}\" (arg1), \"{x12}\" (arg2), \"{x13}\" (arg3) : \"memory\" : \"volatile\"); } ret } pub fn sys_write(ch : u8) -> i32 { sys_call(SyscallId::Write, ch as usize, 0, 0, 0) } pub fn sys_exit(code: usize) -> ! { sys_call(SyscallId::Exit, code, 0, 0, 0); loop{} } enum SyscallId { Write = 64, Exit = 93, } x17 寄存器保存了用户产生的系统调用的编号，x10~x13 寄存器保存了系统调用的参数。用户态产生系统调用后会进入内核态，在内核态中对产生的 syscall 进行处理： // in process/mod.rs pub fn exit(code: usize) { CPU.exit(code); } // in interrupt.rs pub const SYS_WRITE: usize = 64; pub const SYS_EXIT: usize = 93; fn syscall(tf: &mut TrapFrame) { tf.sepc += 4; match tf.x[17] { SYS_WRITE => { print!(\"{}\", tf.x[10] as u8 as char); }, SYS_EXIT => { println!(\"exit!\"); use crate::process::exit; exit(tf.x[10]); }, _ => { println!(\"unknown user syscall !\"); } }; } tf.sepc += 4 这一行的作用是主动跳过当前指令，具体原因在 4. Trap 中提及过。 在 usr/rust/src 目录下创建 lib.rs, lang_items, io.rs ： // in usr/rust/src/lang_items.rs use core::panic::PanicInfo; use core::alloc::Layout; use crate::syscall::*; #[linkage = \"weak\"] // 弱链接，弱外部有 main 函数，则不使用该 main #[no_mangle] fn main() { panic!(\"No main() linked\"); } use crate::ALLOCATOR; fn init_heap() { const HEAP_SIZE: usize = 0x1000; static mut HEAP: [u8; HEAP_SIZE] = [0; HEAP_SIZE]; unsafe { ALLOCATOR.lock().init(HEAP.as_ptr() as usize, HEAP_SIZE); } } #[panic_handler] fn panic(info: &PanicInfo) -> ! { let location = info.location().unwrap(); let message = info.message().unwrap(); println!( \"\\nPANIC in {} at line {} \\n\\t{}\", location.file(), location.line(), message ); loop {} } #[no_mangle] pub extern \"C\" fn _start(_argc: isize, _argv: *const *const u8) -> ! { init_heap(); main(); sys_exit(0) } #[no_mangle] pub extern fn abort() { panic!(\"abort\"); } #[lang = \"oom\"] fn oom(_: Layout) -> ! { panic!(\"out of memory\"); } #[lang = \"eh_personality\"] fn eh_personality() {} // in usr/rust/src/lib.rs #![no_std] #![feature(asm)] #![feature(alloc)] #![feature(lang_items)] #![feature(panic_info_message)] #![feature(linkage)] #![feature(compiler_builtins_lib)] extern crate alloc; #[macro_use] pub mod io; pub mod lang_items; pub mod syscall; use buddy_system_allocator::LockedHeap; #[global_allocator] static ALLOCATOR: LockedHeap = LockedHeap::empty(); // in usr/rust/Cargo.toml [dependencies] buddy_system_allocator = \"0.1\" 上面的内容与我们在编写内核时的基本一致，这里不重复介绍。 usr/rust/src/io.rs 的内容可以直接从内核的 io.rs 复制过来，但是需要将 use bbl::sbi 改为 use super::syscall ，然后修改 putchar 函数为： pub fn putchar(ch: char) { syscall::sys_write(ch as u8); } 复制 riscv32-os.json 至 usr/rust 目录下，删去 \"pre-link-args\": { \"ld.lld\": [\"-Tsrc/boot/linker.ld\"] } 。 最后编写 Makefile ： # in usr/Makefile out_dir ?= build out_img ?= rcore32.img cargo_args := --target riscv32-os.json rust_src_dir := rust/src/bin rust_bin_path := rust/target/riscv32-os/debug rust_bins := $(patsubst $(rust_src_dir)/%.rs, $(rust_bin_path)/%, $(wildcard $(rust_src_dir)/*.rs)) .PHONY: all clean rust all : rust rust : @echo Building rust user program @cd rust && cargo xbuild $(cargo_args) @rm -rf $(out_dir)/rust && mkdir -p $(out_dir)/rust @echo $(out_dir) @echo $(rust_bins) @cp -r $(rust_bins) $(out_dir)/rust clean : @rm -rf $(out_dir) @cd rust && cargo clean @rm -f $(out_img) 在 usr 目录下执行 make ，得到 usr/rust/build/main 二进制文件，这就是我们需要的用户程序。接下来我们就将把该程序链接进内核。 在内核的 Makefile 中将用户程序作为环境变量加入： usr_path := usr/build/rust export SFSIMG = $(usr_path)/main 同时在 init.rs 中加入以下代码： global_asm!(concat!( r#\" .section .data .global _user_img_start .global _user_img_end _user_img_start: .incbin \"\"#, env!(\"SFSIMG\"), r#\"\" _user_img_end: \"# )); 至此我们已经成功将用户程序放入内核，接下来我们需要在内核中解析用户程序并执行。 ELF 文件格式概述 ELF(Executable and linking format) 文件格式是 Linux 系统下的一种常用目标文件(object file)格式，有三种主要类型: 用于执行的 可执行文件(executable file) ，用于提供程序的进程映像，加载的内存执行。 这也是本章使用的文件类型。 用于连接的 可重定位文件(relocatable file) ，可与其它目标文件一起创建可执行文件和共享目标文件。 共享目标文件(shared object file) ，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。 加入以下代码： // in Cargo.toml [dependencies] xmas-elf = \"0.6\" // in process/structs.rs use xmas_elf::{ header, program::{ Flags, SegmentData, Type }, ElfFile, }; ELF header 在文件开始处描述了整个文件的组织，其文件头包含了整个执行文件的控制结构。 program header 描述与程序执行直接相关的目标文件结构信息，用来在文件中定位各个段的映像，同时包含其他一些用来为程序创建进程映像所必需的信息。根据 ELF header 和 program header 的结构描述，我们就可以完成对 ELF 格式文件的加载。 用户页表 首先加入一下内容： // in process/structs.rs use crate::memory_set::{ MemorySet, handler::ByFrame, attr::MemoryAttr}; use crate::memory::frame_allocator::alloc_frames; use crate::consts::*; use crate::process::{ Tid, ExitCode }; use alloc::{ sync::Arc, boxed::Box }; use alloc::alloc::{ alloc, dealloc, Layout }; use riscv::register::satp; use core::str; 在创建用户进程时，需要为用户创建一个页表。因此在 Thread 结构体中增加变量： // in process/structs.rs pub struct Process { vm: Arc, } pub struct Thread { pub context: Context, // 线程相关的上下文 pub kstack: KernelStack, // 线程对应的内核栈 pub proc: Option>, } 同时在 new_idle 和 new_kernel 中分别增加 proc 的初始化： proc: None 。 MemorySet::new_kern 能够一个新的页表，同时映射内核地址，以便产生中断异常的时候能够访问到正确的地址。接下来只需将数据从 ELF 中读取并写入页表即可，具体细节写于注释中： // in process/structs.rs trait ElfExt { fn make_memory_set(&self) -> MemorySet; } impl ElfExt for ElfFile { fn make_memory_set(&self) -> MemorySet { println!(\"creating MemorySet from ELF\"); let mut ms = MemorySet::new_kern(); // 创建自带内核地址空间的虚拟存储系统 for ph in self.program_iter() { // 枚举文件中的程序段 if ph.get_type() != Ok(Type::Load) { continue; } // 获取程序段的大小和起始地址(虚拟的) let virt_addr = ph.virtual_addr() as usize; let mem_size = ph.mem_size() as usize; // 将数据读取为 u8 的数组 let data = match ph.get_data(self).unwrap() { SegmentData::Undefined(data) => data, _ => unreachable!(), }; // Get target slice let target = { // 可以看到，这里的 virt_addr 是根据文件中的虚拟地址得到的，所以 target 应该仅用于 with 函数中 println!(\"virt_addr {:#x}, mem_size {:#x}\", virt_addr, mem_size); ms.push( virt_addr, virt_addr + mem_size, ph.flags().to_attr(), ByFrame::new(), ); unsafe { ::core::slice::from_raw_parts_mut(virt_addr as *mut u8, mem_size) } }; // Copy data unsafe { ms.with(|| { // with 函数的作用是，将当前这个未激活页表激活并执行一个函数，然后切换回原来的页表 if data.len() != 0 { target[..data.len()].copy_from_slice(data); } target[data.len()..].iter_mut().for_each(|x| *x = 0); }); } } ms } } trait ToMemoryAttr { fn to_attr(&self) -> MemoryAttr; } impl ToMemoryAttr for Flags { fn to_attr(&self) -> MemoryAttr { // 将文件中各个段的读写权限转换为页表权限 let mut flags = MemoryAttr::new().set_user(); if self.is_execute() { flags = flags.set_execute(); } flags } } 用户进程的创建和内核线程没有太大的区别，但是多了对 ELF 文件的处理，以及为用户创建堆栈。 // in consts.rs pub const USER_STACK_OFFSET: usize = 0x80000000 - USER_STACK_SIZE; pub const USER_STACK_SIZE: usize = 0x10000; // in process/structs.rs pub unsafe fn new_user(data: &[u8]) -> Box { let elf = ElfFile::new(data).expect(\"failed to read elf\"); // Check ELF type match elf.header.pt2.type_().as_type() { header::Type::Executable => {println!(\"it really a elf\");}, header::Type::SharedObject => {}, _ => panic!(\"ELF is not executable or shared object\"), } // entry_point 代表程序入口在文件中的具体位置 let entry_addr = elf.header.pt2.entry_point() as usize; println!(\"entry: {:#x}\", entry_addr); let mut vm = elf.make_memory_set(); // 为这个 elf 文件创建一个新的虚存系统，其中包含内核的地址空间和elf文件中程序的地址空间 let mut ustack_top = { // 创建用户栈 let (ustack_buttom, ustack_top) = (USER_STACK_OFFSET, USER_STACK_OFFSET + USER_STACK_SIZE); let paddr = alloc_frames(USER_STACK_SIZE / PAGE_SIZE).unwrap().start_address().as_usize(); vm.push( // 创建一个内核栈之后还需要将这个内核栈装入虚存系统。 ustack_buttom, ustack_top, MemoryAttr::new().set_user(), ByFrame::new(), ); ustack_top }; let kstack = KernelStack::new(); //　为用户程序创建内核栈。用于线程切换 Box::new(Thread{ // 注意下面创建上下文使用的是哪个栈 context: Context::new_user_thread(entry_addr, ustack_top, kstack.top(), vm.token()), kstack: kstack, proc: Some(Arc::new(Process{ vm: Arc::new(vm), })), }) } 在从内核态切换至用户态时，需要恢复所有寄存器，同时调用 sret 切换状态。这和我们之前实现的 __trapret 功能是一致的。所以这里可以利用之前完成的函数。首先在 ContextContent 结构体中加入 TrapFrame 变量，然后由于需要通过 sret 进入用户态，所以我们利用之前写的 trap/trap.asm/__trapret 进行中断返回： //in context.rs #[repr(C)] struct ContextContent { ra: usize, // 返回地址 satp: usize, //　二级页表所在位置 s: [usize; 12], // 被调用者保存的寄存器 tf: TrapFrame, // 中断帧 } extern \"C\" { fn __trapret(); } impl ContextContent { fn new_user_thread(entry: usize, ustack_top: usize, satp: usize) -> Self { ContextContent{ ra: __trapret as usize, satp, s: [0;12], tf: { let mut tf: TrapFrame = unsafe { zeroed() }; tf.x[2] = ustack_top; // 栈顶 sp tf.sepc = entry; // sepc 在调用 sret 之后将被被赋值给 PC tf.sstatus = sstatus::read(); tf.sstatus.set_spie(true); tf.sstatus.set_sie(false); tf.sstatus.set_spp(sstatus::SPP::User); // 代表 sret 之后的特权级为U tf }, } } } 注意这里和 new_kernel_thread 不同的地方。在 switch.asm 的最后执行了 ret ，所以会跳转至 ra 保存的地址。对于内核线程，他会跳转至 entry 线程；对用户进程，他会跳转至 __trapret ，经过 RESTORE_ALL 宏恢复寄存器之后，执行 sret 进入用户态，执行用户程序。 Anyway ，用户进程算是实现完了。最后，创建一个用户进程并加入线程池，可以执行 make run 跑一下看看结果吧： // in process/mod.rs extern \"C\" { fn _user_img_start(); fn _user_img_end(); } pub fn init() { println!(\"+------ now to initialize process ------+\"); let scheduler = Scheduler::new(1); let thread_pool = ThreadPool::new(100, scheduler); CPU.init(Thread::new_idle(), Box::new(thread_pool)); ... let data = unsafe{ ::core::slice::from_raw_parts( _user_img_start as *const u8, _user_img_end as usize - _user_img_start as usize, ) }; let user = unsafe{ Thread::new_user(data) }; CPU.add_thread(user); CPU.run(); } const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/命令行.html":{"url":"docs/命令行.html","title":"11. 命令行","keywords":"","body":"命令行 概要 我们要实现的命令行的功能包括：输出、输入、处理输入数据。由于工作量较大，具体的实现分为多个小章节。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/命令行——输出.html":{"url":"docs/命令行——输出.html","title":"11.1. 命令行——输出","keywords":"","body":"命令行——输出 本章代码对应 commit ：8b2476d3892ea5689420cbb1460210ba29bee6bc 打包程序 创建 usr/rust/src/bin/shell.rs ： #![no_std] #![no_main] #[macro_use] extern crate rust; // IMPORTANT: Must define main() like this #[no_mangle] pub fn main() -> i32 { println!(\"Rust user shell\"); loop {} } 修改 Makefile，将用户程序和 shell 打包成 img ： # in Makefile usr_path := usr export SFSIMG = $(usr_path)/rcore32.img # in usr/Makefile .PHONY: all clean rust build all: rust build build: $(out_img) $(out_img): rust @rcore-fs-fuse $@ $(out_dir) zip rcore-fs-fuse: ifeq ($(shell which rcore-fs-fuse),) @echo Installing rcore-fs-fuse @cargo install rcore-fs-fuse --git https://github.com/rcore-os/rcore-fs --rev c611248 endif 执行 make 生成的 rcore32.img 就是我们的目标文件。 解析文件 rcore32.img 里面目前只包含了 shell ，以后可以添加更多的文件。现在我们需要将其中的 shell 解析出来并且加入到线程中： // in process/mod.rs use crate::fs::ROOT_INODE; use crate::fs::INodeExt; pub fn kmain() { CPU.run(); } pub fn init() { println!(\"+------ now to initialize process ------+\"); let scheduler = Scheduler::new(1); let thread_pool = ThreadPool::new(100, scheduler); CPU.init(Thread::new_idle(), Box::new(thread_pool)); let data = ROOT_INODE .lookup(\"rust/shell\") .unwrap() .read_as_vec() .unwrap(); println!(\"size of program {:#x}\", data.len()); let user = unsafe{ Thread::new_user(data.as_slice()) }; CPU.add_thread(user); } // in init.rs use crate::process::{ init as process_init, kmain }; use crate::fs::init as fs_init; #[no_mangle] pub extern \"C\" fn rust_main(hartid: usize, dtb: usize) -> ! { interrupt_init(); println!(\"Hello RISCV ! in hartid {}, dtb @ {:#x} \", hartid, dtb); memory_init(dtb); fs_init(); clock_init(); process_init(); kmain(); loop {} } // in lib.rs mod fs; 这样文件的解析和加载就完成了。看似简单，但是其中最复杂的 fs crate 我们尚未实现。现在我们来填这个坑吧。 文件系统 实现命令行的过程其实包含了实现一个简单的文件系统，创建目录 fs ： // in fs/mod.rs use lazy_static::*; use rcore_fs::vfs::*; use rcore_fs_sfs::SimpleFileSystem; use alloc::{ sync::Arc, vec::Vec }; mod device; lazy_static! { /// The root of file system pub static ref ROOT_INODE: Arc = { let device = { extern { fn _user_img_start(); fn _user_img_end(); } // 将存储磁盘文件的内存范围初始化为虚拟磁盘 Membuf Arc::new(unsafe { device::MemBuf::new(_user_img_start, _user_img_end) }) }; let sfs = SimpleFileSystem::open(device).expect(\"failed to open SFS\"); sfs.root_inode() }; } pub trait INodeExt { fn read_as_vec(&self) -> Result>; } impl INodeExt for INode { fn read_as_vec(&self) -> Result> { let size = self.metadata()?.size; let mut buf = Vec::with_capacity(size); unsafe { buf.set_len(size); } self.read_at(0, buf.as_mut_slice())?; Ok(buf) } } pub fn init() { // 打印当前目录下的所有项的名字 let mut id = 0; while let Ok(name) = ROOT_INODE.get_entry(id) { id += 1; println!(\"{}\", name); } } // in fs/device.rs use spin::RwLock; use rcore_fs::dev::*; pub struct MemBuf(RwLock); impl MemBuf { pub unsafe fn new(begin: unsafe extern \"C\" fn(), end: unsafe extern \"C\" fn()) -> Self { use core::slice; MemBuf(RwLock::new(slice::from_raw_parts_mut( begin as *mut u8, end as usize - begin as usize, ))) } } impl Device for MemBuf { fn read_at(&self, offset: usize, buf: &mut [u8]) -> Result { let slice = self.0.read(); let len = buf.len().min(slice.len() - offset); // 取磁盘剩余长度和 buf 大小的较小值 buf[..len].copy_from_slice(&slice[offset..offset + len]); Ok(len) } fn write_at(&self, offset: usize, buf: &[u8]) -> Result { let mut slice = self.0.write(); let len = buf.len().min(slice.len() - offset); slice[offset..offset + len].copy_from_slice(&buf[..len]); Ok(len) } fn sync(&self) -> Result { Ok(()) } } // in Cargo.toml rcore-fs = { path = \"crate/rcore-fs\" } rcore-fs-sfs = { path = \"crate/rcore-fs-sfs\" } // in init.rs use crate::process::{ init as process_init, kmain }; use crate::fs::init as fs_init; #[no_mangle] pub extern \"C\" fn rust_main(hartid: usize, dtb: usize) -> ! { interrupt_init(); println!(\"Hello RISCV ! in hartid {}, dtb @ {:#x} \", hartid, dtb); memory_init(dtb); fs_init(); clock_init(); process_init(); kmain(); loop {} } 可以将之前生成的 rcore32.img 理解为一块磁盘，里面包含了我们所需要的程序（ELF 格式）。这里将存储磁盘文件的内存范围初始化为虚拟磁盘（Membuf），然后通过 look_up 函数查找虚拟磁盘中的目标内容的起始位置。找到后利用其元数据（metadata）确定长度，最后将该范围内的 ELF 程序读取，最后加载运行。 执行 make run ，可以看到： ... tid to alloc: 0 Rust user shell thread 0 ran just now thread 0 ran just now thread 0 ran just now thread 0 ran just now thread 0 ran just now ... 此时命令行已经可以正常输出文本了，但是我们目前还不能输入任何信息，而这将是我们下一章的工作。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/命令行——输入（信号量）.html":{"url":"docs/命令行——输入（信号量）.html","title":"11.2. 命令行——输入（信号量）","keywords":"","body":"命令行——输入（信号量） 本章代码对应 commit ：1e329bb3c5ad4d58a74837697d5e08ac4904d0bd 用户 shell // in usr/rust/src/bin/shell.rs #![no_std] #![no_main] #[macro_use] extern crate rust; use rust::io::getc; const LF: u8 = 0x0au8; const CR: u8 = 0x0du8; // IMPORTANT: Must define main() like this #[no_mangle] pub fn main() -> i32 { println!(\"Rust user shell\"); loop { let c = getc(); match c { LF | CR => { print!(\"{}\", LF as char); print!(\"{}\", CR as char) } _ => print!(\"{}\", c as char) } } } 目前用户程序只做一件事：循环判断是否有字符输入，如果是回车符号或者换行符号，换行；如果是普通字符就直接打印。 // in usr/rust/src/io.rs pub const STDIN: usize = 0; pub fn getc() -> u8 { let mut c = 0u8; loop { let len = syscall::sys_read(STDIN, &mut c, 1); match len { 1 => return c, 0 => continue, _ => panic!(\"read stdin len = {}\", len), } } } // in usr/rust/src/syscall.rs pub fn sys_read(fd : usize, base : *const u8, len : usize) -> i32 { sys_call(SyscallId::Read, fd, base as usize , len , 0) } enum SyscallId { Read = 63, Write = 64, Exit = 93, } getc 只需简单的向 os 发起一个 syscall 即可。执行 make 编译用户程序，剩下的就是 os 的工作了。 处理 sys_read 首先，我们梳理一下处理 sys_read 的流程： 由用户程序通过 ecall 产生一个 sys_call ，通过传递的参数判断产生了一个 sys_read 请求。 判断缓冲区中是否有字符。 如果有，则返回该字符。 如果没有，则休眠该程序，等待产生键盘中断。 可以预见我们的 syscall 将越来越多，将 syscall 的实现全堆在一个函数里实在是太不优雅了，所以我们需要简化 interrupt::syscall ，并创建 syscall.rs ： // in interrupt.rs fn syscall(tf: &mut TrapFrame) { let ret = crate::syscall::syscall( tf.x[17], [tf.x[10], tf.x[11], tf.x[12]], tf, ); tf.sepc += 4; tf.x[10] = ret as usize; } // in syscall.rs use crate::context::TrapFrame; use crate::process; pub const SYS_READ: usize = 63; pub const SYS_WRITE: usize = 64; pub const SYS_EXIT: usize = 93; pub fn syscall(id: usize, args: [usize;3], tf: &mut TrapFrame) -> isize { match id { SYS_READ => { return sys_read(args[0], args[1] as *mut u8, args[2]); }, SYS_WRITE => { print!(\"{}\", args[0] as u8 as char); return 0; }, SYS_EXIT => { sys_exit(args[0]); }, _ => { panic!(\"unknown syscall id {}\", id); }, }; return 0; } fn sys_exit(code: usize) { process::exit(code); } // in lib.rs mod syscall; // fs/mod.rs pub mod stdio; 每一步看起来都很简单，接下来要做的是通过 crate::fs::stdio::STDIN 中读取缓冲区字符。 缓冲区 所谓缓冲区其实就是一个数组，我们通过识别键盘中断，每产生一次键盘中断，就将按下的字符压入缓冲区中： // in stdio.rs use alloc::{ collections::VecDeque, sync::Arc }; use spin::Mutex; use crate::process; use crate::sync::condvar::*; pub struct Stdin { buf: Mutex>, pushed: Condvar, } impl Stdin { pub fn new() -> Self { Stdin { buf: Mutex::new(VecDeque::new()), pushed: Condvar::new(), } } pub fn push(&self, ch: char) { let mut lock = self.buf.lock(); lock.push_back(ch); drop(lock); self.pushed.notify(); } pub fn pop(&self) -> char { loop{ let ret = self.buf.lock().pop_front(); match ret { Some(ch) => { return ch; }, None => { self.pushed.wait(); }, } } } } use lazy_static::*; lazy_static!{ pub static ref STDIN: Arc = Arc::new(Stdin::new()); } 对于一次 pop 操作，如果缓冲区中存在字符，则将其返回；如果不存在，则将该线程睡眠（不再加入调度）。 如果产生键盘中断（有字符输入），则唤醒休眠队列中的第一个线程，这里我们通过信号量对这些事务进行管理。为了更清晰的理解这里的 push 和 pop 操作，我们先看一下在 interrupt.rs 中是如何调用他们的： // in interrupt.rs use riscv::register::{stvec, sscratch, sie, sstatus}; #[no_mangle] pub fn init() { extern { fn __alltraps(); } unsafe { sscratch::write(0); // 给中断 asm 初始化 sstatus::set_sie(); stvec::write(__alltraps as usize, stvec::TrapMode::Direct); sie::set_sext(); // 开外部中断（串口） } } #[no_mangle] pub extern \"C\" fn rust_trap(tf: &mut TrapFrame) { match tf.scause.cause() { ... Trap::Interrupt(Interrupt::SupervisorExternal) => { let ch = bbl::sbi::console_getchar() as u8 as char; external(ch as u8); }, _ => panic!(\"unexpected trap\"), } } fn external(ch: u8) { crate::fs::stdio::STDIN.push(ch as char); } use crate::process::tick; fn super_timer() { clock_set_next_event(); unsafe{ TICK = TICK + 1; // if TICK % 100 == 0 { // println!(\"100 ticks!\"); // } } tick(); } // in syscall.rs fn sys_read(fd: usize, base: *mut u8, len: usize) -> isize { unsafe { *base = crate::fs::stdio::STDIN.pop() as u8; } return 1; } 简单的信号量 // in sync/mod.rs pub mod condvar; // in lib.rs mod sync; // in sync/condvar.rs use spin::Mutex; use alloc::{ collections::VecDeque, }; use crate::process::{ Tid, current_tid, yield_now, wake_up }; #[derive(Default)] pub struct Condvar { wait_queue: Mutex>, } impl Condvar { pub fn new() -> Self { Condvar::default() } pub fn wait(&self) { let mut queue = self.wait_queue.lock(); queue.push_back(current_tid()); drop(queue); yield_now(); } pub fn notify(&self) { let mut queue = self.wait_queue.lock(); if let Some(tid) = queue.pop_front() { wake_up(tid); drop(queue); yield_now(); } } } 这里的 yield_now 会将当前运行的线程状态置为 Status::Sleeping ，在 ThreadPool.retrieve 中会对线程的状态进行判断，如果是 Status::Ready 或者 Status::Running ，则会将其放入调度队列中，等待下一次调度。否则该线程将不再被调度（除非被 Condvar 重新加入）。 // in process/mod.rs pub fn yield_now() { CPU.yield_now(); } pub fn wake_up(tid : Tid) { CPU.wake_up(tid); } pub fn current_tid() -> usize { CPU.current_tid() } // in process/processor.rs impl Processor { pub fn yield_now(&self) { let inner = self.inner(); if !inner.current.is_none() { unsafe { let flags = disable_and_store(); // 禁止中断，获取当前 sstatus 的状态并保存。 let tid = inner.current.as_mut().unwrap().0; let thread_info = inner.pool.threads[tid].as_mut().expect(\"thread not exits\"); if thread_info.present { thread_info.status = Status::Sleeping; } else { panic!(\"try to sleep an null thread !\"); } inner .current .as_mut() .unwrap() .1 .switch_to(&mut *inner.idle); // 转到 idle 线程重新调度 restore(flags); // 使能中断，恢复 sstatus 的状态 } } } pub fn wake_up(&self, tid: Tid) { let inner = self.inner(); inner.pool.wakeup(tid); } pub fn current_tid(&self) -> usize { self.inner().current.as_mut().unwrap().0 as usize } pub fn run(&self) -> !{ ... // println!(\"thread {} ran just now\", tid); ... } } // in process/thread_pool.rs pub struct ThreadInfo { pub status: Status, pub present: bool, thread: Option>, } pub struct ThreadPool { pub threads: Vec>, // 线程信号量的向量 scheduler: Box, // 调度算法 } impl ThreadPool { ... pub fn retrieve(&mut self, tid: Tid, thread: Box ) { let mut thread_info = self.threads[tid].as_mut().expect(\"thread not exits !\"); if thread_info.present { thread_info.thread = Some(thread); match thread_info.status { Status::Ready | Status::Running(_) => { self.scheduler.push(tid); }, _ => { // println!(\"do nothing!\"); }, } } } pub fn wakeup(&mut self, tid: Tid) { let proc = self.threads[tid].as_mut().expect(\"thread not exist\"); if proc.present { proc.status = Status::Ready; self.scheduler.push(tid); } else { panic!(\"try to sleep an null thread !\"); } } } 执行 make run ，现在我们的命令行已经可以输入文本了，下一个目标是动态执行用户程序。 const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"docs/命令行——执行程序.html":{"url":"docs/命令行——执行程序.html","title":"11.3. 命令行——执行程序","keywords":"","body":"命令行——执行程序 本章代码对应 commit ：ca94d49d69c18ce2925e3949d718cd74ddc3432c 用户程序 在 linux 中，ls, cd， pwd 等命令，其实都是可执行程序。这里我们创建一个简单的 hello 程序： // in usr/rust/src/bin/hello.rs #![no_std] #![no_main] #[macro_use] extern crate rust; #[no_mangle] pub fn main() -> i32 { println!(\"Hello world!\"); return 0; } 接下来，需要修改命令行，使得其能够通过系统调用创建并执行程序： // in usr/rust/src/bin/shell.rs #![no_std] #![no_main] #![feature(alloc)] extern crate alloc; #[macro_use] extern crate rust; use rust::io::getc; use rust::syscall::sys_exec; use alloc::string::String; const LF: u8 = 0x0au8; const CR: u8 = 0x0du8; // IMPORTANT: Must define main() like this #[no_mangle] pub fn main() -> i32 { println!(\"Rust user shell\"); let mut line: String = String::new(); print!(\">> \"); loop { let c = getc(); match c { LF | CR => { println!(\"\"); if !line.is_empty() { sys_exec(line.as_ptr()); line.clear(); } print!(\">> \"); } _ => { print!(\"{}\", c as char); line.push(c as char) } } } } // in usr/rust/bin/shell.rs pub fn sys_exec(path : *const u8) { sys_call(SyscallId::Exec, path as usize, 0, 0, 0); } enum SyscallId { ... Exec = 221, } 用户程序将输入的字符串的指针作为参数传给 os ，os 需要将其转换回字符串，再进行处理： ... pub const SYS_EXEC: usize = 221; pub fn syscall(id: usize, args: [usize;3], tf: &mut TrapFrame) -> isize { match id { ... SYS_EXEC => { sys_exec(args[0] as *const u8); }, _ => { panic!(\"unknown syscall id {}\", id); }, }; return 0; } pub unsafe fn from_cstr(s: *const u8) -> &'static str { use core::{slice, str}; let len = (0usize..).find(|&i| *s.add(i) == 0).unwrap(); str::from_utf8(slice::from_raw_parts(s, len)).unwrap() } fn sys_exec(path : *const u8) -> isize { process::excute(unsafe{ from_cstr(path) }); return 0; } 执行程序的代码在 process::init 中其实已经有了哦，就是创建 shell 的部分： // in process/mod.rs pub fn excute(name : &str) { println!(\"excutint program: {}\", name); let data = ROOT_INODE .lookup(name) .unwrap() .read_as_vec() .unwrap(); let thread = unsafe{ Thread::new_user(data.as_slice()) }; CPU.add_thread(thread); } pub fn init() { println!(\"+------ now to initialize process ------+\"); let scheduler = Scheduler::new(1); let thread_pool = ThreadPool::new(100, scheduler); println!(\"+------ now to initialize processor ------+\"); CPU.init(Thread::new_idle(), Box::new(thread_pool)); excute(\"rust/shell\"); } 这一章没有用到任何新知识呢，是不是学起来很快乐呢（反正我写起来挺快乐。。。（什）） 一些 bug 发现了一些以前写的 bug ： 在 alloc tid 的时候，通过 threads[id].is_none() 判断 id 是否被分配，但是程序 exit 的时候并没有将其还原为 None 。所以需要进行一些修改： pub fn ThreadPool::exit(&mut self, tid: Tid, code: usize) { self.threads[tid] = None; self.scheduler.exit(tid); println!(\"exit code: {}\", code); } pub fn ThreadPool::retrieve(&mut self, tid: Tid, thread: Box ) { if (self.threads[tid].is_none()) { return; } ... } 在 rust/src/lang_items.rs 中，程序结束调用 sys_exit(0) ，返回值被写死了，应该改为： fn rust::lang_items::main() -> usize { panic!(\"No main() linked\"); } #[no_mangle] pub extern \"C\" fn rust::lang_items::_start(_argc: isize, _argv: *const *const u8) -> ! { init_heap(); sys_exit(main()) } const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '6fb135ae71db34448a92', clientSecret: '13668f3df4129768b985879e1456d5a0844dc65f', repo: 'rcore_step_by_step_doc', owner: 'LearningOS', admin: ['xy-plus'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "}}